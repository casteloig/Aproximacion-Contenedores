{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\u00bfQu\u00e9 es un contenedor? La virtualizaci\u00f3n es un proceso mediante el cual un software es usado para crear una abstracci\u00f3n sobre unos recursos, dando la sensaci\u00f3n de que los elementos hardware se dividen en varias computadores virtuales. Existen dos tipos t\u00e9cnicas principales de virtualizaci\u00f3n: M\u00e1quinas virtuales. Contenedores (virtualizaci\u00f3n ligera). Definici\u00f3n Un contenedor es un l\u00edmite l\u00f3gico que se crea dentro de un sistema operativo proporcionado por el aislamiento de recursos hardware. La caracter\u00edstica principal es que en esta t\u00e9cnica se utilizan herramientas que proporciona el Linux Kernel (como cgroups y namespaces ). Diferencia entre MV y contenedores Diferencia infraestructura: VM y contenedor Un contenedor es una forma de virtualizaci\u00f3n ligera . Normalmente envuelve a un peque\u00f1o grupo de procesos . Los contenedores comparten el kernel con el host. Dentro del contendor se encuentra \u00fanicamente el c\u00f3digo, librer\u00edas y ejecutables estrictamente necesarios . Usos principales Microservicios : los contenedores son ligeros y envuelven servicios muy peque\u00f1os , lo que los hace muy aptos para su uso en microservicios. DevOps + CI/CD : facilita el ciclo _\"build, test and deploy\". Cloud : los contenedores pueden funcionar de forma consistente en pr\u00e1cticamente cualquier lugar . Ventajas principales Rapidez y ligereza . Portabilidad e independencia de plataformas . Escalabilidad . Esto es una prueba del actions2","title":"Home"},{"location":"#que-es-un-contenedor","text":"La virtualizaci\u00f3n es un proceso mediante el cual un software es usado para crear una abstracci\u00f3n sobre unos recursos, dando la sensaci\u00f3n de que los elementos hardware se dividen en varias computadores virtuales. Existen dos tipos t\u00e9cnicas principales de virtualizaci\u00f3n: M\u00e1quinas virtuales. Contenedores (virtualizaci\u00f3n ligera). Definici\u00f3n Un contenedor es un l\u00edmite l\u00f3gico que se crea dentro de un sistema operativo proporcionado por el aislamiento de recursos hardware. La caracter\u00edstica principal es que en esta t\u00e9cnica se utilizan herramientas que proporciona el Linux Kernel (como cgroups y namespaces ).","title":"\u00bfQu\u00e9 es un contenedor?"},{"location":"#diferencia-entre-mv-y-contenedores","text":"Diferencia infraestructura: VM y contenedor Un contenedor es una forma de virtualizaci\u00f3n ligera . Normalmente envuelve a un peque\u00f1o grupo de procesos . Los contenedores comparten el kernel con el host. Dentro del contendor se encuentra \u00fanicamente el c\u00f3digo, librer\u00edas y ejecutables estrictamente necesarios . Usos principales Microservicios : los contenedores son ligeros y envuelven servicios muy peque\u00f1os , lo que los hace muy aptos para su uso en microservicios. DevOps + CI/CD : facilita el ciclo _\"build, test and deploy\". Cloud : los contenedores pueden funcionar de forma consistente en pr\u00e1cticamente cualquier lugar . Ventajas principales Rapidez y ligereza . Portabilidad e independencia de plataformas . Escalabilidad . Esto es una prueba del actions2","title":"Diferencia entre MV y contenedores"},{"location":"tutoriales/contenedorbash/","text":"Contenedor en Bash CUIDADO Es muy recomendable utilizar una MV para realizar los siguientes pasos ya que pueden provocar problemas en el sistema si no se realizan correctamente. Namespaces Para crear un contenedor en terminal necesitamos muchas menos instrucciones que para crearlo en Go: contamos con comandos que facilitan enormemente la tarea. En el siguiente ejemplo se crear\u00e1 lo mismo que en el tutorial de Go pero en tan s\u00f3lo unas pocas l\u00edneas. Para el caso de los namespaces simplemente necesitamos utilizar la orden unshare : en este caso crearemos los correspondientes a --mount , --pid , --uts y --user . Adem\u00e1s, vamos a especificar con --fork que la terminal que va a abrir el programa sea un hijo del proceso unshare (es \u00fatil precisamente porque hemos creado un nuevo Namespace PID ). Con --map-root-user ahorramos todas las l\u00edneas que escrib\u00edamos en Go para hacer que el usuario del nuevo Namespace USER sea root. Por \u00faltimo, podemos ahorrar realizar el pivot_root del que ya hemos hablado anteriormente con la opci\u00f3n root=[direcci\u00f3n] . Por otro lado, es importante acordarse de montar el nuevo pseudo-filesystem de /proc . root@bar~$ unshare --mount --pid --uts --user --fork --map-root-user --root = alpinefs /bin/sh root@bar~$ mount -t proc proc proc root@bar~$ hostname demo Cgroups En el caso de los grupos de control, tiene la misma dificultad que en el ejemplo en Go: simplemente hay que crear los directorios correspondientes para cada tipo de Cgroup , eso s\u00ed, desde una terminal con root en el Host, ya que tenemos que introducir el PID en los correspondientes cgroup.procs del Namespace USER superior (es decir, el que vemos desde el host). root @ bar ~$ ps aux | grep / sh root 2552 pts / 0 00 : 13 / bin / sh root @ bar ~$ mkdir / sys / fs / cgroup / pids / demo root @ bar ~$ mkdir / sys / fs / cgroup / memory / demo root @ bar ~$ echo 20 / sys / fs / cgroup / pids / demo / pids . max root @ bar ~$ echo 2552 / sys / fs / cgroup / pids / demo / cgroup . procs root @ bar ~$ echo \"2M\" / sys / fs / cgroup / memory / demo / memory . limit_in_bytes root @ bar ~$ echo 2552 / sys / fs / cgroup / memory / demo / cgroup . procs","title":"Tutorial Bash"},{"location":"tutoriales/contenedorbash/#contenedor-en-bash","text":"CUIDADO Es muy recomendable utilizar una MV para realizar los siguientes pasos ya que pueden provocar problemas en el sistema si no se realizan correctamente.","title":"Contenedor en Bash"},{"location":"tutoriales/contenedorbash/#namespaces","text":"Para crear un contenedor en terminal necesitamos muchas menos instrucciones que para crearlo en Go: contamos con comandos que facilitan enormemente la tarea. En el siguiente ejemplo se crear\u00e1 lo mismo que en el tutorial de Go pero en tan s\u00f3lo unas pocas l\u00edneas. Para el caso de los namespaces simplemente necesitamos utilizar la orden unshare : en este caso crearemos los correspondientes a --mount , --pid , --uts y --user . Adem\u00e1s, vamos a especificar con --fork que la terminal que va a abrir el programa sea un hijo del proceso unshare (es \u00fatil precisamente porque hemos creado un nuevo Namespace PID ). Con --map-root-user ahorramos todas las l\u00edneas que escrib\u00edamos en Go para hacer que el usuario del nuevo Namespace USER sea root. Por \u00faltimo, podemos ahorrar realizar el pivot_root del que ya hemos hablado anteriormente con la opci\u00f3n root=[direcci\u00f3n] . Por otro lado, es importante acordarse de montar el nuevo pseudo-filesystem de /proc . root@bar~$ unshare --mount --pid --uts --user --fork --map-root-user --root = alpinefs /bin/sh root@bar~$ mount -t proc proc proc root@bar~$ hostname demo","title":"Namespaces"},{"location":"tutoriales/contenedorbash/#cgroups","text":"En el caso de los grupos de control, tiene la misma dificultad que en el ejemplo en Go: simplemente hay que crear los directorios correspondientes para cada tipo de Cgroup , eso s\u00ed, desde una terminal con root en el Host, ya que tenemos que introducir el PID en los correspondientes cgroup.procs del Namespace USER superior (es decir, el que vemos desde el host). root @ bar ~$ ps aux | grep / sh root 2552 pts / 0 00 : 13 / bin / sh root @ bar ~$ mkdir / sys / fs / cgroup / pids / demo root @ bar ~$ mkdir / sys / fs / cgroup / memory / demo root @ bar ~$ echo 20 / sys / fs / cgroup / pids / demo / pids . max root @ bar ~$ echo 2552 / sys / fs / cgroup / pids / demo / cgroup . procs root @ bar ~$ echo \"2M\" / sys / fs / cgroup / memory / demo / memory . limit_in_bytes root @ bar ~$ echo 2552 / sys / fs / cgroup / memory / demo / cgroup . procs","title":"Cgroups"},{"location":"tutoriales/contenedorgo/","text":"Tutorial ontenedor en Go CUIDADO Es muy recomendable utilizar una MV para realizar los siguientes pasos ya que pueden provocar problemas en el sistema si no se realizan correctamente. Nuestro objetivo es que, al acabar este tutorial, tengamos un programa que sea capaz de crear un proceso y aislarlo con namespaces y cgroups . De hecho, intentaremos que la interacci\u00f3n con \u00e9ste sea muy parecida a la que tendr\u00edamos cuando ejecutamos un contenedor Docker: # Nosotros vamos a ejecutarlo as\u00ed: root@bar:~$ go run contenedor.go run <command> <args> # Una ejecuci\u00f3n en Docker ser\u00eda algo de este estilo: root@bar:~$ docker run <image> <command> <args> Cabe destacar que es necesario que todos los ficheros est\u00e9n en una carpeta cuyo grupo y usuario pertenezcan a root , as\u00ed como realizar todos los comandos con privilegios de root. Paso 1: Creaci\u00f3n del c\u00f3digo base El primer paso consiste en escribir las primeras dos funciones : main , que simplemente comprobar\u00e1 que se ha ejecutado el comando correcto en terminal y run , que imprimir\u00e1 en pantalla los datos del proceso y ejecutar\u00e1 otro nuevo. package main import ( \"fmt\" \"os\" \"os/exec\" ) func main () { switch os . Args [ 1 ] { case \"run\" : run () default : panic ( \"\u00bfArgumento Invalido?\" ) } } func run () { fmt . Printf ( \"Corriendo '%v' con User ID %d en PID %d \\n\" , os . Args [ 2 :], os . Getuid (), os . Getpid ()) cmd := exec . Command ( os . Args [ 2 ], os . Args [ 3 :] ... ) cmd . Stdin = os . Stdin cmd . Stdout = os . Stdout cmd . Stderr = os . Stderr cmd . Run () } Ahora puedes probar a ejecutar la instrucci\u00f3n go run contenedor.go run ps a y comprobar que se existen dos procesos: el contenedor.go y el ps a que le hemos indicado que ejecute dentro del \"pre-contenedor\". Explicaci\u00f3n La funci\u00f3n run simplemente imprime por pantalla informaci\u00f3n \u00fatil sobre el proceso que estamos ejecutando y que, m\u00e1s adelante, crear\u00e1 el contenedor. De momento, lo \u00fanico que estamos haciendo es indicarle que queremos ejecutar un comando con la funci\u00f3n Command del paquete exec indic\u00e1ndole los argumentos. Este comando devuelve una estructura del tipo Cmd en la que tenemos que especificarle el Stdin Stdout y Stderr . Tambi\u00e9n podemos ejecutar otros comandos dentro del contenedor, como go run contenedor.go run /bin/bash , en cuyo caso se abrir\u00e1 una nueva terminal. Paso 2: Aislando con Namespace UTS (Hostname) Este namespace permite cambiar tanto el hostname como el domain-name del contenedor sin que afecte a estos campos del host. Para lograr este aislamiento debemos a\u00f1adir las siguientes l\u00edneas , adem\u00e1s de importar el paquete necesario syscall : cmd . SysProcAttr = & syscall . SysProcAttr { Cloneflags : syscall . CLONE_NEWUTS , } Con estos cambios lograremos que ,al iniciar el contenedor con go run contenedor.go run /bin/bash , podamos cambiar los el hostname dentro del contenedor y que, al salir del contenedor (saliendo del bash con un exit ) no haya cambiado en el host. C\u00f3digo completo hasta ahora package main import ( \"fmt\" \"os\" \"os/exec\" \"syscall\" ) func main () { switch os . Args [ 1 ] { case \"run\" : run () default : panic ( \"\u00bfArgumento Invalido?\" ) } } func run () { fmt . Printf ( \"Corriendo '%v' con User ID %d en PID %d \\n\" , os . Args [ 2 :], os . Getuid (), os . Getpid ()) cmd := exec . Command ( os . Args [ 2 ], os . Args [ 3 :] ... ) cmd . Stdin = os . Stdin cmd . Stdout = os . Stdout cmd . Stderr = os . Stderr cmd . SysProcAttr = & syscall . SysProcAttr { Cloneflags : syscall . CLONE_NEWUTS , } cmd . Run () } Paso 3: Aislando con Namespace USER (username) Con la inclusi\u00f3n de este namespace vamos a separar las tablas de UID y GID entre el host y el contenedor , de tal forma que dentro del contenedor no haya los mismos usuarios que fuera. Para crear el nuevo namespace simplemente es necesario a\u00f1adir una flag m\u00e1s al c\u00f3digo: cmd . SysProcAttr = & syscall . SysProcAttr { Cloneflags : syscall . CLONE_NEWUTS | syscall . CLONE_NEWUSER , } El problema es que ahora mismo, cuando ejecutamos el contenedor, nos informa que el proceso que lo llama tiene UID 0 pero si comprobamos el usuario que se nos asign\u00f3 en la nueva tabla de UID nos asigna un usuario \"aleatorio\": root@bar:~$ go run contenedor.go run /bin/bash Corriendo '[/bin/bash]' con User ID 0 en PID 2792 root@bar:~$ id uid=65534(nobody) gid=65534(nogroup) groups=65534(nogroup) As\u00ed que le vamos a indicar que mapee el usuario fuera del contenedor (UID 0) con el que queramos dentro : cmd . SysProcAttr = & syscall . SysProcAttr { Cloneflags : syscall . CLONE_NEWUTS | syscall . CLONE_NEWUSER , UidMappings : [] syscall . SysProcIDMap { { ContainerID : 0 , // UID dentro del container HostID : os . Getuid (), // UID en el host Size : 1 , // Quiero mapear solo unuser }, }, GidMappings : [] syscall . SysProcIDMap { { ContainerID : 0 , HostID : os . Getgid (), Size : 1 , }, }, } C\u00f3digo completo hasta ahora package main import ( \"fmt\" \"os\" \"os/exec\" \"syscall\" ) func main () { switch os . Args [ 1 ] { case \"run\" : run () default : panic ( \"\u00bfArgumento Invalido?\" ) } } func run () { fmt . Printf ( \"Corriendo '%v' con User ID %d en PID %d \\n\" , os . Args [ 2 :], os . Getuid (), os . Getpid ()) cmd := exec . Command ( os . Args [ 2 ], os . Args [ 3 :] ... ) cmd . Stdin = os . Stdin cmd . Stdout = os . Stdout cmd . Stderr = os . Stderr cmd . SysProcAttr = & syscall . SysProcAttr { Cloneflags : syscall . CLONE_NEWUTS | syscall . CLONE_NEWUSER , UidMappings : [] syscall . SysProcIDMap { { ContainerID : 0 , // UID dentro del container HostID : os . Getuid (), // UID en el host Size : 1 , // Quiero mapear solo unuser }, }, GidMappings : [] syscall . SysProcIDMap { { ContainerID : 0 , HostID : os . Getpid (), Size : 1 , }, }, } cmd . Run () } Paso 4: Aislando con Namespace NS (Mount) Este fue el primer Namespace que se incluy\u00f3 en el kernel de Linux y uno de los m\u00e1s sencillos: simplemente aisla los puntos de montaje. De tal forma que podemos esconder los montajes del host en el contenedor y viceversa . Para ver los puntos de montaje usados en cada una de las m\u00e1quinas con el comando mount . Para a\u00f1adir esta caracter\u00edstica debemos incluir la flag apropiada: cmd . SysProcAttr = & syscall . SysProcAttr { Cloneflags : syscall . CLONE_NEWUTS | syscall . CLONE_NEWNS | syscall . CLONE_NEWUSER , { ... } } C\u00f3digo completo hasta ahora package main import ( \"fmt\" \"os\" \"os/exec\" \"syscall\" ) func main () { switch os . Args [ 1 ] { case \"run\" : run () default : panic ( \"\u00bfArgumento Invalido?\" ) } } func run () { fmt . Printf ( \"Corriendo '%v' con User ID %d en PID %d \\n\" , os . Args [ 2 :], os . Getuid (), os . Getpid ()) cmd := exec . Command ( os . Args [ 2 ], os . Args [ 3 :] ... ) cmd . Stdin = os . Stdin cmd . Stdout = os . Stdout cmd . Stderr = os . Stderr cmd . SysProcAttr = & syscall . SysProcAttr { Cloneflags : syscall . CLONE_NEWUTS | syscall . CLONE_ syscall . CLONE_NEWUSER , UidMappings : [] syscall . SysProcIDMap { { ContainerID : 0 , // UID dentro del container HostID : os . Getuid (), // UID en el host Size : 1 , // Quiero mapear solo unuser }, }, GidMappings : [] syscall . SysProcIDMap { { ContainerID : 0 , HostID : os . Getpid (), Size : 1 , }, }, } cmd . Run () } Paso 5: Aislando con Namespace PID El PID namespace permite separar los \u00e1rboles de procesos, de tal forma que dentro del contenedor no se pueden ver los procesos del host . Para a\u00f1adir este namespace simplemente incluimos la flag apropiada: cmd . SysProcAttr = & syscall . SysProcAttr { Cloneflags : syscall . CLONE_NEWUTS | syscall . CLONE_NEWUSER | syscall . CLONE_NEWNS | syscall . CLONE_NEWPID , } Sin embargo, cuando ejecutamos un ps a seguimos pudiendo ver los mismos procesos de antes. Explicaci\u00f3n: Mount Namespace no a\u00edsla los procesos\". Es importante saber que /proc es un pseudo-filesystem montado por el sistema operativo por defecto donde se muestra la informaci\u00f3n sobre los procesos. Cuando hacemos un ps a , lo que est\u00e1 pasando realmente es que esta instrucci\u00f3n consulta los datos del directorio anteriormente nombrado. La soluci\u00f3n es asignar un nuevo /proc en la ra\u00edz del contenedor. Para ello necesitamos un nuevo root filesystem como Alpine (que continene \u00fanicamente los archivos necesarios para que funcione un contenedor). Paso 6: A\u00f1adiendo un Filesystem para el contenedor Para realizar este paso necesitamos descargar el mini-root de Alpine. Lo descomprimimos y lo llamamos, por ejemplo, alpinefs y le cambiamos el usuario con chown root alpinefs/ . Montamos nuestro propio /proc Necesitamos un nuevo directorio proc para que el comando ps a pueda acceder a \u00e9l para acceder a la informaci\u00f3n de los procesos del contnedor. Explicaci\u00f3n: directorio /proc Otra cosa que se podr\u00eda intuir es que es necesario a\u00f1adir el Namespace NS (de Mount) para aislar ambos directorios. Pero no, este \u00faltimo comentario es falso pese a que existan muchas referencias en la red a que es completamente necesario: cuando un proceso como ps quiere comprobar los procesos activos en /proc lo que hace es ir directamente a ese archivo. Nuestro proceso, tanto con el Namespace NS como sin \u00e9l, va a seguir mirando los procesos en la carpeta /proc , es decir, la que est\u00e1 justo debajo del directorio ra\u00edz y no en la del nuevo root filesystem de alpine. As\u00ed que podr\u00edamos montar nuestro nuevo proc/ sin el Namespace NS . La soluci\u00f3n de que se muestren \u00fanicamente los procesos activos de nuestro contenedor se divide en dos pasos, pero antes, debemos cambiar un poco la forma en la que hab\u00edamos planteado el programa en un principio. Ahora, en vez de ejecutar desde la funci\u00f3n run la instrucci\u00f3n indicada en los par\u00e1metros, vamos a duplicar el proceso actual llamando a /proc/self/exe para que esta segunda vez cambie el flujo de ejecuci\u00f3n y no pase por la funci\u00f3n run , sino por la funci\u00f3n child . cmd := exec . Command ( \"/proc/self/exe\" , append ([] string { \"child\" }, os . Args [ 2 :] ... ) ... ) De esta forma, habr\u00eda otra funci\u00f3n dentro del programa que se ejecutar\u00eda la segunda vez, donde implementamos la soluci\u00f3n a nuestro \u00faltimo problema: Hacer la nueva ra\u00edz de nuestro contenedor la ra\u00edz del filesystem que acabamos de descargar ( alpinefs/ ) para que al acceder a /proc est\u00e9 accediendo al nuevo y no al del Host. Esto se puede hacer tanto con la llamada al sistema chroot o pivot_root . La segunda opci\u00f3n es m\u00e1s segura, aunque m\u00e1s complicada. Por lo tanto, para evitar aumentar demasiado la complejidad se utilizar\u00e1 el primer m\u00e9todo (anexando el segundo al final del tutorial). Montar el filesystem proc para que el sistema pueda utilizarlo para almacenar informaci\u00f3n sobre los procesos. func child () { fmt . Printf ( \"Running '%v' as user %d in PID %d \\n\" , os . Args [ 2 :], os . Getuid (), os . Getpid ()) must ( syscall . Chroot ( \"alpinefs/\" )) must ( os . Chdir ( \"/\" )) must ( syscall . Mount ( \"proc\" , \"proc\" , \"proc\" , 0 , \"\" )) cmd := exec . Command ( os . Args [ 2 ], os . Args [ 3 :] ... ) cmd . Stdin = os . Stdin cmd . Stdout = os . Stdout cmd . Stderr = os . Stderr defer func () { must ( syscall . Unmount ( \"proc\" , 0 )) }() must ( cmd . Run ()) } Explicaci\u00f3n: \u00bfpor qu\u00e9 crear una nueva funci\u00f3n? Ahora no s\u00f3lo vamos a a\u00f1adir namespaces y ejecutar una instrucci\u00f3n sino que vamos a realizar otras acciones. Si cogemos el flujo de la funci\u00f3n run y realizamos las nuevas acciones despu\u00e9s de cmd.Run() no se estar\u00edan completando hasta que acabara esta \u00faltima orden. A su vez, si introducimos las acciones antes de cmd.Run() no se estar\u00edan creando a\u00fan los namespaces : es justo en mientras transcurre en cmd.Run() cuando queremos modificar el contenedor. Por eso una opci\u00f3n es obligar al proceso a llamarse a una copia de s\u00ed mismo y cambiar el flujo del programa a la nueva funci\u00f3n child . Cabe destacar que el filesystem propuesto de Alpine no cuenta con Bash, as\u00ed que tendr\u00edamos que mandar ejecutar /bin/sh Por otro lado, es recomendable que a partir de ahora empezemos a manejar los errores que nos puedan aparecer: func must ( err error ) { if err != nil { panic ( err ) } } C\u00f3digo completo hasta ahora package main import ( \"fmt\" \"os\" \"os/exec\" \"syscall\" ) func main () { switch os . Args [ 1 ] { case \"run\" : run () case \"child\" : child () default : panic ( \"\u00bfArgumento Invalido?\" ) } } func run () { fmt . Printf ( \"Corriendo '%v' con User ID %d en PID %d \\n\" , os . Args [ 2 :], os . Getuid (), os . Getpid ()) cmd := exec . Command ( \"/proc/self/exe\" , append ([] string { \"child\" }, os . Args [ 2 :] ... ) ... ) cmd . Stdin = os . Stdin cmd . Stdout = os . Stdout cmd . Stderr = os . Stderr cmd . SysProcAttr = & syscall . SysProcAttr { Cloneflags : syscall . CLONE_NEWUTS | syscall . CLONE_NEWUSER | syscall . CLONE_NEWNS | syscall . CLONE_NEWPID , UidMappings : [] syscall . SysProcIDMap { { ContainerID : 0 , HostID : os . Getuid (), Size : 1 , }, }, GidMappings : [] syscall . SysProcIDMap { { ContainerID : 0 , HostID : os . Getgid (), Size : 1 , }, }, } must ( cmd . Run ()) } func child () { fmt . Printf ( \"Corriendo '%v' con User ID %d en PID %d \\n\" , os . Args [ 2 :], os . Getuid (), os . Getpid ()) must ( syscall . Sethostname ([] byte ( \"container\" ))) must ( syscall . Chroot ( \"alpinefs/\" )) must ( os . Chdir ( \"/\" )) must ( syscall . Mount ( \"proc\" , \"proc\" , \"proc\" , 0 , \"\" )) cmd := exec . Command ( os . Args [ 2 ], os . Args [ 3 :] ... ) cmd . Stdin = os . Stdin cmd . Stdout = os . Stdout cmd . Stderr = os . Stderr defer func () { must ( syscall . Unmount ( \"proc\" , 0 )) }() must ( cmd . Run ()) } func must ( err error ) { if err != nil { panic ( err ) } } \u00bfQU\u00c9 HEMOS CONSEGUIDO HASTA AHORA? En estos momentos hemos conseguido introducir unos cuantos namespaces , al menos los m\u00e1s significativos para realizar en este tutorial. El hostname namespace se puede comprobar de esta forma: # Fuera del contenedor root@bar:~$ hostname host root@bar:~$ go run contenedor.go run /bin/sh Corriendo '[/bin/sh]' con User ID 0 en PID 72724 # Dentro del contenedor root@bar:~$ sethostname contenedor root@bar:~$ exit # Fuera del contenedor root@bar:~$ hostname host El user namespace lo hemos conseguido introducir a\u00f1adiendo los mapeos de usuario a root dentro del contenedor. Lo podemos comprobar de esta forma: # Fuera del contenedor root@bar:~$ go run contenedor.go run /bin/sh Corriendo '[/bin/sh]' con User ID 0 en PID 72724 # Dentro del contenedor root@bar:~$ id uid=0(root) gid=0(root) groups=0(root) El mount namespace se puede comprobar de una forma muy sencilla: # Fuera del contenedor root@bar:~$ mount # ##### Aparecen muchos puntos de montaje usados por el host root@bar:~$ go run contenedor.go run /bin/sh Corriendo '[/bin/sh]' con User ID 0 en PID 72724 # Dentro del contenedor root@bar:~$ mount proc on /proc type proc (rw,relatime) El pid namespace lo podemos comprobar realizando las siguientes instrucciones: # Fuera del contenedor root@bar:~$ go run contenedor.go run /bin/sh Corriendo '[/bin/sh]' con User ID 0 en PID 72724 # Dentro del contenedor root@bar:~$ ps a PID USER TIME COMMAND 1 root 0:00 /proc/self/exe child /bin/sh 5 root 0:00 /bin/sh 11 root 0:00 ps a A\u00f1adiendo Cgroups (memoria y PID) En este ejemplo a\u00f1adiremos un l\u00edmite al n\u00famero m\u00e1ximo de procesos en el cgroup (y, por lo tanto, en el contenedor) permitidos. Para ello necesitamos crear un nuevo directorio en /sys/fs/cgroup/pids/ . Al crear el directorio autom\u00e1ticamente el sistema a\u00f1ade los archivos necesarios para mostrar los datos del nuevo Cgroup y para modificar los l\u00edmites que se le quieran a\u00f1adir. En nuestro caso el grupo se llamar\u00e1 demo . Para modificar el n\u00famero m\u00e1ximo de procesos que se permite en el contenedor s\u00f3lo es necesario modificar el archivo donde se indica el n\u00famero (pondremos como m\u00e1ximo 12 procesos) y otro donde se introduce al proceso del contenedor en el grupo de control. Adem\u00e1s a\u00f1adiremos un n\u00famero m\u00e1ximo de bytes de memoria que se le asignan al contenedor, aunque esto es m\u00e1s complicado de comprobar que funciona correctamente, pero los pasos son los mismos que en el anterior caso. func cg () cgroups := \"/sys/fs/cgroup\" // Creando cgroup para PIDs pids := filepath . Join ( cgroups , \"pids/demo\" ) if _ , err := os . Stat ( pids ); os . IsNotExist ( err ) { must ( os . Mkdir ( pids , 0755 )) } // Creando cgroup para PIDs memory := filepath . Join ( cgroups , \"memory/demo\" ) if _ , err := os . Stat ( memory ); os . IsnotExist ( err ) { must ( os . Mkdir ( memory , 0755 )) } //Establecemos limite y metemos al proceso dentro del grupo de procesos must ( ioutil . WriteFile ( filepath . Join ( pids , \"pids.max\" ), [] byte ( \"10\" ), 0700 )) must ( ioutil . WriteFile ( filepath . Join ( pids , \"cgroup.procs\" ), [] byte ( strconv . Itoa ( os . Getpid ())), 0700 )) must ( ioutil . WriteFile ( filepath . Join ( memory , \"memory.limit_in_bytes\" ), [] byte ( \"2M\" ), 0700 )) must ( ioutil . WriteFile ( filepath . Join ( memory , \"cgroup.procs\" ), [] byte ( strconv . Itoa ( os . Getpid ())), 0700 )) } S\u00f3lo hace falta llamar a esta funci\u00f3n desde el principio de la funci\u00f3n child . Anexo: mejora con pivot_root Cuando se introdujo en el tutorial la llamada al sistema chroot se mencion\u00f3 la posibilidad de utilizar otra m\u00e1s segura: pivot_root . Aunque antiguamente, en los primeros contenedores, se utilizaba la primera opci\u00f3n, se ha llegado a la conclusi\u00f3n de que tiene varios fallos de seguridad que permiten \"salir o escapar\" del contenedor. pivot_root aprovecha el mount namespace ya que permite hacer unmount del antiguo root y no lo hace accesible en el namespace del contenedor. Si usamos \u00fanicamente chroot podemos acceder al Host con el siguiente comando: chroot /proc/1/root . Lo que hay que saber para poder usar pivot_root es que necesita dos argumentos, el primero es la direcci\u00f3n del nuevo directorio ra\u00edz (no viene en la documentaci\u00f3n pero debe estar montado sobre s\u00ed mismo con la opci\u00f3n bind ) y el segundo es la direcci\u00f3n donde se va a situar el antiguo directorio ra\u00edz. El c\u00f3digo completo del tutorial quedar\u00eda as\u00ed: C\u00d3DIGO COMPLETO package main import ( \"fmt\" \"os\" \"os/exec\" \"syscall\" \"io/ioutil\" \"strconv\" \"path/filepath\" ) func main () { switch os . Args [ 1 ] { case \"run\" : run () case \"child\" : child () default : panic ( \"\u00bfArgumento Invalido?\" ) } } func run () { fmt . Printf ( \"Corriendo '%v' con User ID %d en PID %d \\n\" , os . Args [ 2 :], os . Getuid (), os . Getpid ()) cmd := exec . Command ( \"/proc/self/exe\" , append ([] string { \"child\" }, os . Args [ 2 :] ... ) ... ) cmd . Stdin = os . Stdin cmd . Stdout = os . Stdout cmd . Stderr = os . Stderr cmd . SysProcAttr = & syscall . SysProcAttr { Cloneflags : syscall . CLONE_NEWUTS | syscall . CLONE_NEWUSER | syscall . CLONE_NEWNS | syscall . CLONE_NEWPID , UidMappings : [] syscall . SysProcIDMap { { ContainerID : 0 , HostID : os . Getuid (), Size : 1 , }, }, GidMappings : [] syscall . SysProcIDMap { { ContainerID : 0 , HostID : os . Getgid (), Size : 1 , }, }, } must ( cmd . Run ()) } func child () { fmt . Printf ( \"Corriendo '%v' con User ID %d en PID %d \\n\" , os . Args [ 2 :], os . Getuid (), os . Getpid ()) cg () must ( syscall . Sethostname ([] byte ( \"container\" ))) pivot () must ( syscall . Mount ( \"proc\" , \"proc\" , \"proc\" , 0 , \"\" )) cmd := exec . Command ( os . Args [ 2 ], os . Args [ 3 :] ... ) cmd . Stdin = os . Stdin cmd . Stdout = os . Stdout cmd . Stderr = os . Stderr must ( syscall . Unmount ( \".old_root\" , syscall . MNT_DETACH )) must ( os . Remove ( \".old_root\" )) defer func () { must ( syscall . Unmount ( \"proc\" , 0 )) }() must ( cmd . Run ()) } func cg () { cgroups := \"/sys/fs/cgroup\" pids := filepath . Join ( cgroups , \"pids/demo\" ) if _ , err := os . Stat ( pids ); os . IsNotExist ( err ) { must ( os . Mkdir ( pids , 0755 )) } memory := filepath . Join ( cgroups , \"memory/demo\" ) if _ , err := os . Stat ( memory ); os . IsNotExist ( err ) { must ( os . Mkdir ( memory , 0755 )) } must ( ioutil . WriteFile ( filepath . Join ( pids , \"pids.max\" ), [] byte ( \"22\" ), 0700 )) must ( ioutil . WriteFile ( filepath . Join ( pids , \"cgroup.procs\" ), [] byte ( strconv . Itoa ( os . Getpid ())), 0700 )) must ( ioutil . WriteFile ( filepath . Join ( memory , \"memory.limit_in_bytes\" ), [] byte ( \"2M\" ), 0700 )) must ( ioutil . WriteFile ( filepath . Join ( memory , \"cgroup.procs\" ), [] byte ( strconv . Itoa ( os . Getpid ())), 0700 )) } func pivot () { must ( syscall . Mount ( \"alpinefs\" , \"alpinefs\" , \"\" , syscall . MS_BIND | syscall . MS_REC , \"\" )) if _ , err := os . Stat ( \"alpinefs/.old_root\" ); os . IsNotExist ( err ) { must ( os . Mkdir ( \"alpinefs/.old_root\" , 0700 )) } must ( syscall . PivotRoot ( \"alpinefs\" , \"alpinefs/.old_root\" )) must ( os . Chdir ( \"/\" )) } func must ( err error ) { if err != nil { panic ( err ) } }","title":"Tutorial Go"},{"location":"tutoriales/contenedorgo/#tutorial-ontenedor-en-go","text":"CUIDADO Es muy recomendable utilizar una MV para realizar los siguientes pasos ya que pueden provocar problemas en el sistema si no se realizan correctamente. Nuestro objetivo es que, al acabar este tutorial, tengamos un programa que sea capaz de crear un proceso y aislarlo con namespaces y cgroups . De hecho, intentaremos que la interacci\u00f3n con \u00e9ste sea muy parecida a la que tendr\u00edamos cuando ejecutamos un contenedor Docker: # Nosotros vamos a ejecutarlo as\u00ed: root@bar:~$ go run contenedor.go run <command> <args> # Una ejecuci\u00f3n en Docker ser\u00eda algo de este estilo: root@bar:~$ docker run <image> <command> <args> Cabe destacar que es necesario que todos los ficheros est\u00e9n en una carpeta cuyo grupo y usuario pertenezcan a root , as\u00ed como realizar todos los comandos con privilegios de root.","title":"Tutorial ontenedor en Go"},{"location":"tutoriales/contenedorgo/#paso-1-creacion-del-codigo-base","text":"El primer paso consiste en escribir las primeras dos funciones : main , que simplemente comprobar\u00e1 que se ha ejecutado el comando correcto en terminal y run , que imprimir\u00e1 en pantalla los datos del proceso y ejecutar\u00e1 otro nuevo. package main import ( \"fmt\" \"os\" \"os/exec\" ) func main () { switch os . Args [ 1 ] { case \"run\" : run () default : panic ( \"\u00bfArgumento Invalido?\" ) } } func run () { fmt . Printf ( \"Corriendo '%v' con User ID %d en PID %d \\n\" , os . Args [ 2 :], os . Getuid (), os . Getpid ()) cmd := exec . Command ( os . Args [ 2 ], os . Args [ 3 :] ... ) cmd . Stdin = os . Stdin cmd . Stdout = os . Stdout cmd . Stderr = os . Stderr cmd . Run () } Ahora puedes probar a ejecutar la instrucci\u00f3n go run contenedor.go run ps a y comprobar que se existen dos procesos: el contenedor.go y el ps a que le hemos indicado que ejecute dentro del \"pre-contenedor\". Explicaci\u00f3n La funci\u00f3n run simplemente imprime por pantalla informaci\u00f3n \u00fatil sobre el proceso que estamos ejecutando y que, m\u00e1s adelante, crear\u00e1 el contenedor. De momento, lo \u00fanico que estamos haciendo es indicarle que queremos ejecutar un comando con la funci\u00f3n Command del paquete exec indic\u00e1ndole los argumentos. Este comando devuelve una estructura del tipo Cmd en la que tenemos que especificarle el Stdin Stdout y Stderr . Tambi\u00e9n podemos ejecutar otros comandos dentro del contenedor, como go run contenedor.go run /bin/bash , en cuyo caso se abrir\u00e1 una nueva terminal.","title":"Paso 1: Creaci\u00f3n del c\u00f3digo base"},{"location":"tutoriales/contenedorgo/#paso-2-aislando-con-namespace-uts-hostname","text":"Este namespace permite cambiar tanto el hostname como el domain-name del contenedor sin que afecte a estos campos del host. Para lograr este aislamiento debemos a\u00f1adir las siguientes l\u00edneas , adem\u00e1s de importar el paquete necesario syscall : cmd . SysProcAttr = & syscall . SysProcAttr { Cloneflags : syscall . CLONE_NEWUTS , } Con estos cambios lograremos que ,al iniciar el contenedor con go run contenedor.go run /bin/bash , podamos cambiar los el hostname dentro del contenedor y que, al salir del contenedor (saliendo del bash con un exit ) no haya cambiado en el host. C\u00f3digo completo hasta ahora package main import ( \"fmt\" \"os\" \"os/exec\" \"syscall\" ) func main () { switch os . Args [ 1 ] { case \"run\" : run () default : panic ( \"\u00bfArgumento Invalido?\" ) } } func run () { fmt . Printf ( \"Corriendo '%v' con User ID %d en PID %d \\n\" , os . Args [ 2 :], os . Getuid (), os . Getpid ()) cmd := exec . Command ( os . Args [ 2 ], os . Args [ 3 :] ... ) cmd . Stdin = os . Stdin cmd . Stdout = os . Stdout cmd . Stderr = os . Stderr cmd . SysProcAttr = & syscall . SysProcAttr { Cloneflags : syscall . CLONE_NEWUTS , } cmd . Run () }","title":"Paso 2: Aislando con Namespace UTS (Hostname)"},{"location":"tutoriales/contenedorgo/#paso-3-aislando-con-namespace-user-username","text":"Con la inclusi\u00f3n de este namespace vamos a separar las tablas de UID y GID entre el host y el contenedor , de tal forma que dentro del contenedor no haya los mismos usuarios que fuera. Para crear el nuevo namespace simplemente es necesario a\u00f1adir una flag m\u00e1s al c\u00f3digo: cmd . SysProcAttr = & syscall . SysProcAttr { Cloneflags : syscall . CLONE_NEWUTS | syscall . CLONE_NEWUSER , } El problema es que ahora mismo, cuando ejecutamos el contenedor, nos informa que el proceso que lo llama tiene UID 0 pero si comprobamos el usuario que se nos asign\u00f3 en la nueva tabla de UID nos asigna un usuario \"aleatorio\": root@bar:~$ go run contenedor.go run /bin/bash Corriendo '[/bin/bash]' con User ID 0 en PID 2792 root@bar:~$ id uid=65534(nobody) gid=65534(nogroup) groups=65534(nogroup) As\u00ed que le vamos a indicar que mapee el usuario fuera del contenedor (UID 0) con el que queramos dentro : cmd . SysProcAttr = & syscall . SysProcAttr { Cloneflags : syscall . CLONE_NEWUTS | syscall . CLONE_NEWUSER , UidMappings : [] syscall . SysProcIDMap { { ContainerID : 0 , // UID dentro del container HostID : os . Getuid (), // UID en el host Size : 1 , // Quiero mapear solo unuser }, }, GidMappings : [] syscall . SysProcIDMap { { ContainerID : 0 , HostID : os . Getgid (), Size : 1 , }, }, } C\u00f3digo completo hasta ahora package main import ( \"fmt\" \"os\" \"os/exec\" \"syscall\" ) func main () { switch os . Args [ 1 ] { case \"run\" : run () default : panic ( \"\u00bfArgumento Invalido?\" ) } } func run () { fmt . Printf ( \"Corriendo '%v' con User ID %d en PID %d \\n\" , os . Args [ 2 :], os . Getuid (), os . Getpid ()) cmd := exec . Command ( os . Args [ 2 ], os . Args [ 3 :] ... ) cmd . Stdin = os . Stdin cmd . Stdout = os . Stdout cmd . Stderr = os . Stderr cmd . SysProcAttr = & syscall . SysProcAttr { Cloneflags : syscall . CLONE_NEWUTS | syscall . CLONE_NEWUSER , UidMappings : [] syscall . SysProcIDMap { { ContainerID : 0 , // UID dentro del container HostID : os . Getuid (), // UID en el host Size : 1 , // Quiero mapear solo unuser }, }, GidMappings : [] syscall . SysProcIDMap { { ContainerID : 0 , HostID : os . Getpid (), Size : 1 , }, }, } cmd . Run () }","title":"Paso 3: Aislando con Namespace USER (username)"},{"location":"tutoriales/contenedorgo/#paso-4-aislando-con-namespace-ns-mount","text":"Este fue el primer Namespace que se incluy\u00f3 en el kernel de Linux y uno de los m\u00e1s sencillos: simplemente aisla los puntos de montaje. De tal forma que podemos esconder los montajes del host en el contenedor y viceversa . Para ver los puntos de montaje usados en cada una de las m\u00e1quinas con el comando mount . Para a\u00f1adir esta caracter\u00edstica debemos incluir la flag apropiada: cmd . SysProcAttr = & syscall . SysProcAttr { Cloneflags : syscall . CLONE_NEWUTS | syscall . CLONE_NEWNS | syscall . CLONE_NEWUSER , { ... } } C\u00f3digo completo hasta ahora package main import ( \"fmt\" \"os\" \"os/exec\" \"syscall\" ) func main () { switch os . Args [ 1 ] { case \"run\" : run () default : panic ( \"\u00bfArgumento Invalido?\" ) } } func run () { fmt . Printf ( \"Corriendo '%v' con User ID %d en PID %d \\n\" , os . Args [ 2 :], os . Getuid (), os . Getpid ()) cmd := exec . Command ( os . Args [ 2 ], os . Args [ 3 :] ... ) cmd . Stdin = os . Stdin cmd . Stdout = os . Stdout cmd . Stderr = os . Stderr cmd . SysProcAttr = & syscall . SysProcAttr { Cloneflags : syscall . CLONE_NEWUTS | syscall . CLONE_ syscall . CLONE_NEWUSER , UidMappings : [] syscall . SysProcIDMap { { ContainerID : 0 , // UID dentro del container HostID : os . Getuid (), // UID en el host Size : 1 , // Quiero mapear solo unuser }, }, GidMappings : [] syscall . SysProcIDMap { { ContainerID : 0 , HostID : os . Getpid (), Size : 1 , }, }, } cmd . Run () }","title":"Paso 4: Aislando con Namespace NS (Mount)"},{"location":"tutoriales/contenedorgo/#paso-5-aislando-con-namespace-pid","text":"El PID namespace permite separar los \u00e1rboles de procesos, de tal forma que dentro del contenedor no se pueden ver los procesos del host . Para a\u00f1adir este namespace simplemente incluimos la flag apropiada: cmd . SysProcAttr = & syscall . SysProcAttr { Cloneflags : syscall . CLONE_NEWUTS | syscall . CLONE_NEWUSER | syscall . CLONE_NEWNS | syscall . CLONE_NEWPID , } Sin embargo, cuando ejecutamos un ps a seguimos pudiendo ver los mismos procesos de antes. Explicaci\u00f3n: Mount Namespace no a\u00edsla los procesos\". Es importante saber que /proc es un pseudo-filesystem montado por el sistema operativo por defecto donde se muestra la informaci\u00f3n sobre los procesos. Cuando hacemos un ps a , lo que est\u00e1 pasando realmente es que esta instrucci\u00f3n consulta los datos del directorio anteriormente nombrado. La soluci\u00f3n es asignar un nuevo /proc en la ra\u00edz del contenedor. Para ello necesitamos un nuevo root filesystem como Alpine (que continene \u00fanicamente los archivos necesarios para que funcione un contenedor).","title":"Paso 5: Aislando con Namespace PID"},{"location":"tutoriales/contenedorgo/#paso-6-anadiendo-un-filesystem-para-el-contenedor","text":"Para realizar este paso necesitamos descargar el mini-root de Alpine. Lo descomprimimos y lo llamamos, por ejemplo, alpinefs y le cambiamos el usuario con chown root alpinefs/ .","title":"Paso 6: A\u00f1adiendo un Filesystem para el contenedor"},{"location":"tutoriales/contenedorgo/#montamos-nuestro-propio-proc","text":"Necesitamos un nuevo directorio proc para que el comando ps a pueda acceder a \u00e9l para acceder a la informaci\u00f3n de los procesos del contnedor. Explicaci\u00f3n: directorio /proc Otra cosa que se podr\u00eda intuir es que es necesario a\u00f1adir el Namespace NS (de Mount) para aislar ambos directorios. Pero no, este \u00faltimo comentario es falso pese a que existan muchas referencias en la red a que es completamente necesario: cuando un proceso como ps quiere comprobar los procesos activos en /proc lo que hace es ir directamente a ese archivo. Nuestro proceso, tanto con el Namespace NS como sin \u00e9l, va a seguir mirando los procesos en la carpeta /proc , es decir, la que est\u00e1 justo debajo del directorio ra\u00edz y no en la del nuevo root filesystem de alpine. As\u00ed que podr\u00edamos montar nuestro nuevo proc/ sin el Namespace NS . La soluci\u00f3n de que se muestren \u00fanicamente los procesos activos de nuestro contenedor se divide en dos pasos, pero antes, debemos cambiar un poco la forma en la que hab\u00edamos planteado el programa en un principio. Ahora, en vez de ejecutar desde la funci\u00f3n run la instrucci\u00f3n indicada en los par\u00e1metros, vamos a duplicar el proceso actual llamando a /proc/self/exe para que esta segunda vez cambie el flujo de ejecuci\u00f3n y no pase por la funci\u00f3n run , sino por la funci\u00f3n child . cmd := exec . Command ( \"/proc/self/exe\" , append ([] string { \"child\" }, os . Args [ 2 :] ... ) ... ) De esta forma, habr\u00eda otra funci\u00f3n dentro del programa que se ejecutar\u00eda la segunda vez, donde implementamos la soluci\u00f3n a nuestro \u00faltimo problema: Hacer la nueva ra\u00edz de nuestro contenedor la ra\u00edz del filesystem que acabamos de descargar ( alpinefs/ ) para que al acceder a /proc est\u00e9 accediendo al nuevo y no al del Host. Esto se puede hacer tanto con la llamada al sistema chroot o pivot_root . La segunda opci\u00f3n es m\u00e1s segura, aunque m\u00e1s complicada. Por lo tanto, para evitar aumentar demasiado la complejidad se utilizar\u00e1 el primer m\u00e9todo (anexando el segundo al final del tutorial). Montar el filesystem proc para que el sistema pueda utilizarlo para almacenar informaci\u00f3n sobre los procesos. func child () { fmt . Printf ( \"Running '%v' as user %d in PID %d \\n\" , os . Args [ 2 :], os . Getuid (), os . Getpid ()) must ( syscall . Chroot ( \"alpinefs/\" )) must ( os . Chdir ( \"/\" )) must ( syscall . Mount ( \"proc\" , \"proc\" , \"proc\" , 0 , \"\" )) cmd := exec . Command ( os . Args [ 2 ], os . Args [ 3 :] ... ) cmd . Stdin = os . Stdin cmd . Stdout = os . Stdout cmd . Stderr = os . Stderr defer func () { must ( syscall . Unmount ( \"proc\" , 0 )) }() must ( cmd . Run ()) } Explicaci\u00f3n: \u00bfpor qu\u00e9 crear una nueva funci\u00f3n? Ahora no s\u00f3lo vamos a a\u00f1adir namespaces y ejecutar una instrucci\u00f3n sino que vamos a realizar otras acciones. Si cogemos el flujo de la funci\u00f3n run y realizamos las nuevas acciones despu\u00e9s de cmd.Run() no se estar\u00edan completando hasta que acabara esta \u00faltima orden. A su vez, si introducimos las acciones antes de cmd.Run() no se estar\u00edan creando a\u00fan los namespaces : es justo en mientras transcurre en cmd.Run() cuando queremos modificar el contenedor. Por eso una opci\u00f3n es obligar al proceso a llamarse a una copia de s\u00ed mismo y cambiar el flujo del programa a la nueva funci\u00f3n child . Cabe destacar que el filesystem propuesto de Alpine no cuenta con Bash, as\u00ed que tendr\u00edamos que mandar ejecutar /bin/sh Por otro lado, es recomendable que a partir de ahora empezemos a manejar los errores que nos puedan aparecer: func must ( err error ) { if err != nil { panic ( err ) } } C\u00f3digo completo hasta ahora package main import ( \"fmt\" \"os\" \"os/exec\" \"syscall\" ) func main () { switch os . Args [ 1 ] { case \"run\" : run () case \"child\" : child () default : panic ( \"\u00bfArgumento Invalido?\" ) } } func run () { fmt . Printf ( \"Corriendo '%v' con User ID %d en PID %d \\n\" , os . Args [ 2 :], os . Getuid (), os . Getpid ()) cmd := exec . Command ( \"/proc/self/exe\" , append ([] string { \"child\" }, os . Args [ 2 :] ... ) ... ) cmd . Stdin = os . Stdin cmd . Stdout = os . Stdout cmd . Stderr = os . Stderr cmd . SysProcAttr = & syscall . SysProcAttr { Cloneflags : syscall . CLONE_NEWUTS | syscall . CLONE_NEWUSER | syscall . CLONE_NEWNS | syscall . CLONE_NEWPID , UidMappings : [] syscall . SysProcIDMap { { ContainerID : 0 , HostID : os . Getuid (), Size : 1 , }, }, GidMappings : [] syscall . SysProcIDMap { { ContainerID : 0 , HostID : os . Getgid (), Size : 1 , }, }, } must ( cmd . Run ()) } func child () { fmt . Printf ( \"Corriendo '%v' con User ID %d en PID %d \\n\" , os . Args [ 2 :], os . Getuid (), os . Getpid ()) must ( syscall . Sethostname ([] byte ( \"container\" ))) must ( syscall . Chroot ( \"alpinefs/\" )) must ( os . Chdir ( \"/\" )) must ( syscall . Mount ( \"proc\" , \"proc\" , \"proc\" , 0 , \"\" )) cmd := exec . Command ( os . Args [ 2 ], os . Args [ 3 :] ... ) cmd . Stdin = os . Stdin cmd . Stdout = os . Stdout cmd . Stderr = os . Stderr defer func () { must ( syscall . Unmount ( \"proc\" , 0 )) }() must ( cmd . Run ()) } func must ( err error ) { if err != nil { panic ( err ) } } \u00bfQU\u00c9 HEMOS CONSEGUIDO HASTA AHORA? En estos momentos hemos conseguido introducir unos cuantos namespaces , al menos los m\u00e1s significativos para realizar en este tutorial. El hostname namespace se puede comprobar de esta forma: # Fuera del contenedor root@bar:~$ hostname host root@bar:~$ go run contenedor.go run /bin/sh Corriendo '[/bin/sh]' con User ID 0 en PID 72724 # Dentro del contenedor root@bar:~$ sethostname contenedor root@bar:~$ exit # Fuera del contenedor root@bar:~$ hostname host El user namespace lo hemos conseguido introducir a\u00f1adiendo los mapeos de usuario a root dentro del contenedor. Lo podemos comprobar de esta forma: # Fuera del contenedor root@bar:~$ go run contenedor.go run /bin/sh Corriendo '[/bin/sh]' con User ID 0 en PID 72724 # Dentro del contenedor root@bar:~$ id uid=0(root) gid=0(root) groups=0(root) El mount namespace se puede comprobar de una forma muy sencilla: # Fuera del contenedor root@bar:~$ mount # ##### Aparecen muchos puntos de montaje usados por el host root@bar:~$ go run contenedor.go run /bin/sh Corriendo '[/bin/sh]' con User ID 0 en PID 72724 # Dentro del contenedor root@bar:~$ mount proc on /proc type proc (rw,relatime) El pid namespace lo podemos comprobar realizando las siguientes instrucciones: # Fuera del contenedor root@bar:~$ go run contenedor.go run /bin/sh Corriendo '[/bin/sh]' con User ID 0 en PID 72724 # Dentro del contenedor root@bar:~$ ps a PID USER TIME COMMAND 1 root 0:00 /proc/self/exe child /bin/sh 5 root 0:00 /bin/sh 11 root 0:00 ps a","title":"Montamos nuestro propio /proc"},{"location":"tutoriales/contenedorgo/#anadiendo-cgroups-memoria-y-pid","text":"En este ejemplo a\u00f1adiremos un l\u00edmite al n\u00famero m\u00e1ximo de procesos en el cgroup (y, por lo tanto, en el contenedor) permitidos. Para ello necesitamos crear un nuevo directorio en /sys/fs/cgroup/pids/ . Al crear el directorio autom\u00e1ticamente el sistema a\u00f1ade los archivos necesarios para mostrar los datos del nuevo Cgroup y para modificar los l\u00edmites que se le quieran a\u00f1adir. En nuestro caso el grupo se llamar\u00e1 demo . Para modificar el n\u00famero m\u00e1ximo de procesos que se permite en el contenedor s\u00f3lo es necesario modificar el archivo donde se indica el n\u00famero (pondremos como m\u00e1ximo 12 procesos) y otro donde se introduce al proceso del contenedor en el grupo de control. Adem\u00e1s a\u00f1adiremos un n\u00famero m\u00e1ximo de bytes de memoria que se le asignan al contenedor, aunque esto es m\u00e1s complicado de comprobar que funciona correctamente, pero los pasos son los mismos que en el anterior caso. func cg () cgroups := \"/sys/fs/cgroup\" // Creando cgroup para PIDs pids := filepath . Join ( cgroups , \"pids/demo\" ) if _ , err := os . Stat ( pids ); os . IsNotExist ( err ) { must ( os . Mkdir ( pids , 0755 )) } // Creando cgroup para PIDs memory := filepath . Join ( cgroups , \"memory/demo\" ) if _ , err := os . Stat ( memory ); os . IsnotExist ( err ) { must ( os . Mkdir ( memory , 0755 )) } //Establecemos limite y metemos al proceso dentro del grupo de procesos must ( ioutil . WriteFile ( filepath . Join ( pids , \"pids.max\" ), [] byte ( \"10\" ), 0700 )) must ( ioutil . WriteFile ( filepath . Join ( pids , \"cgroup.procs\" ), [] byte ( strconv . Itoa ( os . Getpid ())), 0700 )) must ( ioutil . WriteFile ( filepath . Join ( memory , \"memory.limit_in_bytes\" ), [] byte ( \"2M\" ), 0700 )) must ( ioutil . WriteFile ( filepath . Join ( memory , \"cgroup.procs\" ), [] byte ( strconv . Itoa ( os . Getpid ())), 0700 )) } S\u00f3lo hace falta llamar a esta funci\u00f3n desde el principio de la funci\u00f3n child .","title":"A\u00f1adiendo Cgroups (memoria y PID)"},{"location":"tutoriales/contenedorgo/#anexo-mejora-con-pivot_root","text":"Cuando se introdujo en el tutorial la llamada al sistema chroot se mencion\u00f3 la posibilidad de utilizar otra m\u00e1s segura: pivot_root . Aunque antiguamente, en los primeros contenedores, se utilizaba la primera opci\u00f3n, se ha llegado a la conclusi\u00f3n de que tiene varios fallos de seguridad que permiten \"salir o escapar\" del contenedor. pivot_root aprovecha el mount namespace ya que permite hacer unmount del antiguo root y no lo hace accesible en el namespace del contenedor. Si usamos \u00fanicamente chroot podemos acceder al Host con el siguiente comando: chroot /proc/1/root . Lo que hay que saber para poder usar pivot_root es que necesita dos argumentos, el primero es la direcci\u00f3n del nuevo directorio ra\u00edz (no viene en la documentaci\u00f3n pero debe estar montado sobre s\u00ed mismo con la opci\u00f3n bind ) y el segundo es la direcci\u00f3n donde se va a situar el antiguo directorio ra\u00edz. El c\u00f3digo completo del tutorial quedar\u00eda as\u00ed: C\u00d3DIGO COMPLETO package main import ( \"fmt\" \"os\" \"os/exec\" \"syscall\" \"io/ioutil\" \"strconv\" \"path/filepath\" ) func main () { switch os . Args [ 1 ] { case \"run\" : run () case \"child\" : child () default : panic ( \"\u00bfArgumento Invalido?\" ) } } func run () { fmt . Printf ( \"Corriendo '%v' con User ID %d en PID %d \\n\" , os . Args [ 2 :], os . Getuid (), os . Getpid ()) cmd := exec . Command ( \"/proc/self/exe\" , append ([] string { \"child\" }, os . Args [ 2 :] ... ) ... ) cmd . Stdin = os . Stdin cmd . Stdout = os . Stdout cmd . Stderr = os . Stderr cmd . SysProcAttr = & syscall . SysProcAttr { Cloneflags : syscall . CLONE_NEWUTS | syscall . CLONE_NEWUSER | syscall . CLONE_NEWNS | syscall . CLONE_NEWPID , UidMappings : [] syscall . SysProcIDMap { { ContainerID : 0 , HostID : os . Getuid (), Size : 1 , }, }, GidMappings : [] syscall . SysProcIDMap { { ContainerID : 0 , HostID : os . Getgid (), Size : 1 , }, }, } must ( cmd . Run ()) } func child () { fmt . Printf ( \"Corriendo '%v' con User ID %d en PID %d \\n\" , os . Args [ 2 :], os . Getuid (), os . Getpid ()) cg () must ( syscall . Sethostname ([] byte ( \"container\" ))) pivot () must ( syscall . Mount ( \"proc\" , \"proc\" , \"proc\" , 0 , \"\" )) cmd := exec . Command ( os . Args [ 2 ], os . Args [ 3 :] ... ) cmd . Stdin = os . Stdin cmd . Stdout = os . Stdout cmd . Stderr = os . Stderr must ( syscall . Unmount ( \".old_root\" , syscall . MNT_DETACH )) must ( os . Remove ( \".old_root\" )) defer func () { must ( syscall . Unmount ( \"proc\" , 0 )) }() must ( cmd . Run ()) } func cg () { cgroups := \"/sys/fs/cgroup\" pids := filepath . Join ( cgroups , \"pids/demo\" ) if _ , err := os . Stat ( pids ); os . IsNotExist ( err ) { must ( os . Mkdir ( pids , 0755 )) } memory := filepath . Join ( cgroups , \"memory/demo\" ) if _ , err := os . Stat ( memory ); os . IsNotExist ( err ) { must ( os . Mkdir ( memory , 0755 )) } must ( ioutil . WriteFile ( filepath . Join ( pids , \"pids.max\" ), [] byte ( \"22\" ), 0700 )) must ( ioutil . WriteFile ( filepath . Join ( pids , \"cgroup.procs\" ), [] byte ( strconv . Itoa ( os . Getpid ())), 0700 )) must ( ioutil . WriteFile ( filepath . Join ( memory , \"memory.limit_in_bytes\" ), [] byte ( \"2M\" ), 0700 )) must ( ioutil . WriteFile ( filepath . Join ( memory , \"cgroup.procs\" ), [] byte ( strconv . Itoa ( os . Getpid ())), 0700 )) } func pivot () { must ( syscall . Mount ( \"alpinefs\" , \"alpinefs\" , \"\" , syscall . MS_BIND | syscall . MS_REC , \"\" )) if _ , err := os . Stat ( \"alpinefs/.old_root\" ); os . IsNotExist ( err ) { must ( os . Mkdir ( \"alpinefs/.old_root\" , 0700 )) } must ( syscall . PivotRoot ( \"alpinefs\" , \"alpinefs/.old_root\" )) must ( os . Chdir ( \"/\" )) } func must ( err error ) { if err != nil { panic ( err ) } }","title":"Anexo: mejora con pivot_root"}]}