{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Tutorial ontenedor en Go Warning Es muy recomendable utilizar una MV para realizar los siguientes pasos ya que pueden provocar problemas en el sistema si no se realizan correctamente. Nuestro objetivo es que, al acabar este tutorial, tengamos un programa que sea capaz de crear un proceso y aislarlo con namespaces y cgroups . De hecho, intentaremos que la interacci\u00f3n con \u00e9ste sea muy parecida a la que tendr\u00edamos cuando ejecutamos un contenedor Docker: # Nosotros vamos a ejecutarlo as\u00ed: root@bar:~$ go run contenedor.go run <command> <args> # Una ejecuci\u00f3n en Docker ser\u00eda algo de este estilo: root@bar:~$ docker run <image> <command> <args> Cabe destacar que es necesario que todos los ficheros est\u00e9n en una carpeta cuyo grupo y usuario pertenezcan a root , as\u00ed como realizar todos los comandos con privilegios de root. Paso 1: Creaci\u00f3n del c\u00f3digo base El primer paso consiste en escribir las primeras dos funciones : main , que simplemente comprobar\u00e1 que se ha ejecutado el comando correcto en terminal y run , que imprimir\u00e1 en pantalla los datos del proceso y ejecutar\u00e1 otro nuevo. package main import ( \"fmt\" \"os\" \"os/exec\" ) func main() { switch os.Args[1] { case \"run\": run() default: panic(\"\u00bfArgumento Invalido?\") } } func run() { fmt.Printf(\"Corriendo '%v' con User ID %d en PID %d \\n\", os.Args[2:], os.Getuid(), os.Getpid()) cmd := exec.Command(os.Args[2], os.Args[3:]...) cmd.Stdin = os.Stdin cmd.Stdout = os.Stdout cmd.Stderr = os.Stderr cmd.Run() } Ahora puedes probar a ejecutar la instrucci\u00f3n go run contenedor.go run ps a y comprobar que se existen dos procesos: el contenedor.go y el ps a que le hemos indicado que ejecute dentro del \"pre-contenedor\". Explicaci\u00f3n La funci\u00f3n `run` simplemente imprime por pantalla informaci\u00f3n \u00fatil sobre el proceso que estamos ejecutando y que, m\u00e1s adelante, crear\u00e1 el contenedor. De momento, lo \u00fanico que estamos haciendo es indicarle que queremos ejecutar un comando con la funci\u00f3n `Command` del paquete [`exec`](https://golang.org/pkg/os/exec/) indic\u00e1ndole los argumentos. Este comando devuelve una estructura del tipo `Cmd` en la que tenemos que especificarle el _Stdin_ _Stdout_ y _Stderr_. Tambi\u00e9n podemos ejecutar otros comandos dentro del contenedor, como `go run contenedor.go run /bin/bash`, en cuyo caso se abrir\u00e1 una nueva terminal. Paso 2: Aislando con Namespace UTS (Hostname) Este namespace permite cambiar tanto el hostname como el domain-name del contenedor sin que afecte a estos campos del host. Para lograr este aislamiento debemos a\u00f1adir las siguientes l\u00edneas , adem\u00e1s de importar el paquete necesario syscall : cmd.SysProcAttr = &syscall.SysProcAttr{ Cloneflags: syscall.CLONE_NEWUTS, } Con estos cambios lograremos que ,al iniciar el contenedor con go run contenedor.go run /bin/bash , podamos cambiar los el hostname dentro del contenedor y que, al salir del contenedor (saliendo del bash con un exit ) no haya cambiado en el host. C\u00f3digo completo hasta ahora. package main import ( \"fmt\" \"os\" \"os/exec\" \"syscall\" ) func main() { switch os.Args[1] { case \"run\": run() default: panic(\"\u00bfArgumento Invalido?\") } } func run() { fmt.Printf(\"Corriendo '%v' con User ID %d en PID %d \\n\", os.Args[2:], os.Getuid(), os.Getpid()) cmd := exec.Command(os.Args[2], os.Args[3:]...) cmd.Stdin = os.Stdin cmd.Stdout = os.Stdout cmd.Stderr = os.Stderr cmd.SysProcAttr = &syscall.SysProcAttr{ Cloneflags: syscall.CLONE_NEWUTS, } cmd.Run() } Paso 3: Aislando con Namespace USER (username) Con la inclusi\u00f3n de este namespace vamos a separar las tablas de UID y GID entre el host y el contenedor , de tal forma que dentro del contenedor no haya los mismos usuarios que fuera. Para crear el nuevo namespace simplemente es necesario a\u00f1adir una flag m\u00e1s al c\u00f3digo: cmd.SysProcAttr = &syscall.SysProcAttr{ Cloneflags: syscall.CLONE_NEWUTS | syscall.CLONE_NEWUSER, } El problema es que ahora mismo, cuando ejecutamos el contenedor, nos informa que el proceso que lo llama tiene UID 0 pero si comprobamos el usuario que se nos asign\u00f3 en la nueva tabla de UID nos asigna un usuario \"aleatorio\": root@bar:~$ go run contenedor.go run /bin/bash Corriendo '[/bin/bash]' con User ID 0 en PID 2792 root@bar:~$ id uid=65534(nobody) gid=65534(nogroup) groups=65534(nogroup) As\u00ed que le vamos a indicar que mapee el usuario fuera del contenedor (UID 0) con el que queramos dentro : cmd.SysProcAttr = &syscall.SysProcAttr{ Cloneflags: syscall.CLONE_NEWUTS | syscall.CLONE_NEWUSER, UidMappings: []syscall.SysProcIDMap{ { ContainerID: 0, // UID dentro del container HostID: os.Getuid(), // UID en el host Size: 1, // Quiero mapear solo unuser }, }, GidMappings: []syscall.SysProcIDMap{ { ContainerID: 0, HostID: os.Getgid(), Size: 1, }, }, } C\u00f3digo completo hasta ahora. package main import ( \"fmt\" \"os\" \"os/exec\" \"syscall\" ) func main() { switch os.Args[1] { case \"run\": run() default: panic(\"\u00bfArgumento Invalido?\") } } func run() { fmt.Printf(\"Corriendo '%v' con User ID %d en PID %d \\n\", os.Args[2:], os.Getuid(), os.Getpid()) cmd := exec.Command(os.Args[2], os.Args[3:]...) cmd.Stdin = os.Stdin cmd.Stdout = os.Stdout cmd.Stderr = os.Stderr cmd.SysProcAttr = &syscall.SysProcAttr{ Cloneflags: syscall.CLONE_NEWUTS | syscall.CLONE_NEWUSER, UidMappings: []syscall.SysProcIDMap{ { ContainerID: 0, // UID dentro del container HostID: os.Getuid(), // UID en el host Size: 1, // Quiero mapear solo unuser }, }, GidMappings: []syscall.SysProcIDMap{ { ContainerID: 0, HostID: os.Getpid(), Size: 1, }, }, } cmd.Run() } Paso 4: Aislando con Namespace NS (Mount) Este fue el primer Namespace que se incluy\u00f3 en el kernel de Linux y uno de los m\u00e1s sencillos: simplemente aisla los puntos de montaje. De tal forma que podemos esconder los montajes del host en el contenedor y viceversa . Para ver los puntos de montaje usados en cada una de las m\u00e1quinas con el comando mount . Para a\u00f1adir esta caracter\u00edstica debemos incluir la flag apropiada: cmd.SysProcAttr = &syscall.SysProcAttr{ Cloneflags: syscall.CLONE_NEWUTS | syscall.CLONE_NEWNS | syscall.CLONE_NEWUSER, {...} } C\u00f3digo completo hasta ahora. package main import ( \"fmt\" \"os\" \"os/exec\" \"syscall\" ) func main() { switch os.Args[1] { case \"run\": run() default: panic(\"\u00bfArgumento Invalido?\") } } func run() { fmt.Printf(\"Corriendo '%v' con User ID %d en PID %d \\n\", os.Args[2:], os.Getuid(), os.Getpid()) cmd := exec.Command(os.Args[2], os.Args[3:]...) cmd.Stdin = os.Stdin cmd.Stdout = os.Stdout cmd.Stderr = os.Stderr cmd.SysProcAttr = &syscall.SysProcAttr{ Cloneflags: syscall.CLONE_NEWUTS | syscall.CLONE_ syscall.CLONE_NEWUSER, UidMappings: []syscall.SysProcIDMap{ { ContainerID: 0, // UID dentro del container HostID: os.Getuid(), // UID en el host Size: 1, // Quiero mapear solo unuser }, }, GidMappings: []syscall.SysProcIDMap{ { ContainerID: 0, HostID: os.Getpid(), Size: 1, }, }, } cmd.Run() } Paso 5: Aislando con Namespace PID El PID namespace permite separar los \u00e1rboles de procesos, de tal forma que dentro del contenedor no se pueden ver los procesos del host . Para a\u00f1adir este namespace simplemente incluimos la flag apropiada: cmd.SysProcAttr = &syscall.SysProcAttr{ Cloneflags: syscall.CLONE_NEWUTS | syscall.CLONE_NEWUSER | syscall.CLONE_NEWNS | syscall.CLONE_NEWPID, } Sin embargo, cuando ejecutamos un ps a seguimos pudiendo ver los mismos procesos de antes. Explicaci\u00f3n: Mount Namespace no a\u00edsla los procesos. Es importante saber que **_/proc_** es un pseudo-filesystem montado por el sistema operativo por defecto donde se muestra la informaci\u00f3n sobre los procesos. Cuando hacemos un **_ps a_**, lo que est\u00e1 pasando realmente es que esta instrucci\u00f3n consulta los datos del directorio anteriormente nombrado. La soluci\u00f3n es asignar un nuevo /proc en la ra\u00edz del contenedor. Para ello necesitamos un nuevo root filesystem como Alpine (que continene \u00fanicamente los archivos necesarios para que funcione un contenedor). Paso 6: A\u00f1adiendo un Filesystem para el contenedor Para realizar este paso necesitamos descargar el mini-root de Alpine. Lo descomprimimos y lo llamamos, por ejemplo, alpinefs y le cambiamos el usuario con chown root alpinefs/ . Montamos nuestro propio /proc Necesitamos un nuevo directorio proc para que el comando ps a pueda acceder a \u00e9l para acceder a la informaci\u00f3n de los procesos del contnedor. Explicaci\u00f3n: directorio /proc Otra cosa que se podr\u00eda intuir es que es necesario a\u00f1adir el _Namespace NS (de Mount)_ para aislar ambos directorios. Pero no, este \u00faltimo comentario es falso pese a que existan muchas referencias en la red a que es completamente necesario: cuando un proceso como `ps` quiere comprobar los procesos activos en `/proc` lo que hace es ir directamente a ese archivo. Nuestro proceso, tanto con el _Namespace NS_ como sin \u00e9l, va a seguir mirando los procesos en la carpeta `/proc`, es decir, la que est\u00e1 justo debajo del directorio ra\u00edz y no en la del nuevo _root filesystem_ de alpine. As\u00ed que podr\u00edamos montar nuestro nuevo `proc/` sin el _Namespace NS_. La soluci\u00f3n de que se muestren \u00fanicamente los procesos activos de nuestro contenedor se divide en dos pasos, pero antes, debemos cambiar un poco la forma en la que hab\u00edamos planteado el programa en un principio. Ahora, en vez de ejecutar desde la funci\u00f3n run la instrucci\u00f3n indicada en los par\u00e1metros, vamos a duplicar el proceso actual llamando a /proc/self/exe para que esta segunda vez cambie el flujo de ejecuci\u00f3n y no pase por la funci\u00f3n run , sino por la funci\u00f3n child . cmd := exec.Command (\"/proc/self/exe\", append([]string {\"child\"}, os.Args[2:]...)...) De esta forma, habr\u00eda otra funci\u00f3n dentro del programa que se ejecutar\u00eda la segunda vez, donde implementamos la soluci\u00f3n a nuestro \u00faltimo problema: Hacer la nueva ra\u00edz de nuestro contenedor la ra\u00edz del filesystem que acabamos de descargar ( alpinefs/ ) para que al acceder a /proc est\u00e9 accediendo al nuevo y no al del Host. Esto se puede hacer tanto con la llamada al sistema chroot o pivot_root . La segunda opci\u00f3n es m\u00e1s segura, aunque m\u00e1s complicada. Por lo tanto, para evitar aumentar demasiado la complejidad se utilizar\u00e1 el primer m\u00e9todo (anexando el segundo al final del tutorial). Montar el filesystem proc para que el sistema pueda utilizarlo para almacenar informaci\u00f3n sobre los procesos. func child() { fmt.Printf(\"Running '%v' as user %d in PID %d \\n\", os.Args[2:], os.Getuid(), os.Getpid()) must(syscall.Chroot(\"alpinefs/\")) must(os.Chdir(\"/\")) must(syscall.Mount(\"proc\", \"proc\", \"proc\", 0, \"\")) cmd := exec.Command(os.Args[2], os.Args[3:]...) cmd.Stdin = os.Stdin cmd.Stdout = os.Stdout cmd.Stderr = os.Stderr defer func() { must(syscall.Unmount(\"proc\", 0)) }() must(cmd.Run()) } Explicaci\u00f3n: \u00bfpor qu\u00e9 crear una nueva funci\u00f3n? Ahora no s\u00f3lo vamos a a\u00f1adir _namespaces_ y ejecutar una instrucci\u00f3n sino que vamos a realizar otras acciones. Si cogemos el flujo de la funci\u00f3n `run` y realizamos las nuevas acciones despu\u00e9s de `cmd.Run()` no se estar\u00edan completando hasta que acabara esta \u00faltima orden. A su vez, si introducimos las acciones antes de `cmd.Run()` no se estar\u00edan creando a\u00fan los _namespaces_: es justo en mientras transcurre en `cmd.Run()` cuando queremos modificar el contenedor. Por eso una opci\u00f3n es obligar al proceso a llamarse a una copia de s\u00ed mismo y cambiar el flujo del programa a la nueva funci\u00f3n `child`. Cabe destacar que el _filesystem_ propuesto de Alpine no cuenta con Bash, as\u00ed que tendr\u00edamos que mandar ejecutar `/bin/sh` Por otro lado, es recomendable que a partir de ahora empezemos a manejar los errores que nos puedan aparecer: func must(err error) { if err != nil { panic(err) } } C\u00f3digo completo hasta ahora package main import ( \"fmt\" \"os\" \"os/exec\" \"syscall\" ) func main() { switch os.Args[1] { case \"run\": run() case \"child\": child() default: panic(\"\u00bfArgumento Invalido?\") } } func run() { fmt.Printf(\"Corriendo '%v' con User ID %d en PID %d \\n\", os.Args[2:], os.Getuid(), os.Getpid()) cmd := exec.Command(\"/proc/self/exe\", append([]string{\"child\"}, os.Args[2:]...)...) cmd.Stdin = os.Stdin cmd.Stdout= os.Stdout cmd.Stderr = os.Stderr cmd.SysProcAttr = &syscall.SysProcAttr{ Cloneflags: syscall.CLONE_NEWUTS | syscall.CLONE_NEWUSER | syscall.CLONE_NEWNS | syscall.CLONE_NEWPID, UidMappings: []syscall.SysProcIDMap{ { ContainerID: 0, HostID: os.Getuid(), Size: 1, }, }, GidMappings: []syscall.SysProcIDMap{ { ContainerID: 0, HostID: os.Getgid(), Size: 1, }, }, } must(cmd.Run()) } func child() { fmt.Printf(\"Corriendo '%v' con User ID %d en PID %d \\n\", os.Args[2:], os.Getuid(), os.Getpid()) must(syscall.Sethostname([]byte(\"container\"))) must(syscall.Chroot(\"alpinefs/\")) must(os.Chdir(\"/\")) must(syscall.Mount(\"proc\", \"proc\", \"proc\", 0, \"\")) cmd := exec.Command(os.Args[2], os.Args[3:]...) cmd.Stdin = os.Stdin cmd.Stdout = os.Stdout cmd.Stderr = os.Stderr defer func() { must(syscall.Unmount(\"proc\", 0)) }() must(cmd.Run()) } func must(err error) { if err != nil { panic(err) } } \u00bfQU\u00c9 HEMOS CONSEGUIDO HASTA AHORA? En estos momentos hemos conseguido introducir unos cuantos _namespaces_, al menos los m\u00e1s significativos para realizar en este tutorial. El hostname namespace se puede comprobar de esta forma: # Fuera del contenedor root@bar:~$ hostname host root@bar:~$ go run contenedor.go run /bin/sh Corriendo '[/bin/sh]' con User ID 0 en PID 72724 # Dentro del contenedor root@bar:~$ sethostname contenedor root@bar:~$ exit # Fuera del contenedor root@bar:~$ hostname host El user namespace lo hemos conseguido introducir a\u00f1adiendo los mapeos de usuario a root dentro del contenedor. Lo podemos comprobar de esta forma: # Fuera del contenedor root@bar:~$ go run contenedor.go run /bin/sh Corriendo '[/bin/sh]' con User ID 0 en PID 72724 # Dentro del contenedor root@bar:~$ id uid=0(root) gid=0(root) groups=0(root) El mount namespace se puede comprobar de una forma muy sencilla: # Fuera del contenedor root@bar:~$ mount ###### Aparecen muchos puntos de montaje usados por el host root@bar:~$ go run contenedor.go run /bin/sh Corriendo '[/bin/sh]' con User ID 0 en PID 72724 # Dentro del contenedor root@bar:~$ mount proc on /proc type proc (rw,relatime) El pid namespace lo podemos comprobar realizando las siguientes instrucciones: # Fuera del contenedor root@bar:~$ go run contenedor.go run /bin/sh Corriendo '[/bin/sh]' con User ID 0 en PID 72724 # Dentro del contenedor root@bar:~$ ps a PID USER TIME COMMAND 1 root 0:00 /proc/self/exe child /bin/sh 5 root 0:00 /bin/sh 11 root 0:00 ps a A\u00f1adiendo Cgroups (memoria y PID) En este ejemplo a\u00f1adiremos un l\u00edmite al n\u00famero m\u00e1ximo de procesos en el cgroup (y, por lo tanto, en el contenedor) permitidos. Para ello necesitamos crear un nuevo directorio en /sys/fs/cgroup/pids/ . Al crear el directorio autom\u00e1ticamente el sistema a\u00f1ade los archivos necesarios para mostrar los datos del nuevo Cgroup y para modificar los l\u00edmites que se le quieran a\u00f1adir. En nuestro caso el grupo se llamar\u00e1 demo . Para modificar el n\u00famero m\u00e1ximo de procesos que se permite en el contenedor s\u00f3lo es necesario modificar el archivo donde se indica el n\u00famero (pondremos como m\u00e1ximo 12 procesos) y otro donde se introduce al proceso del contenedor en el grupo de control. Adem\u00e1s a\u00f1adiremos un n\u00famero m\u00e1ximo de bytes de memoria que se le asignan al contenedor, aunque esto es m\u00e1s complicado de comprobar que funciona correctamente, pero los pasos son los mismos que en el anterior caso. func cg() cgroups := \"/sys/fs/cgroup\" // Creando cgroup para PIDs pids := filepath.Join(cgroups, \"pids/demo\") if _, err := os.Stat(pids); os.IsNotExist(err) { must(os.Mkdir(pids, 0755)) } // Creando cgroup para PIDs memory := filepath.Join(cgroups, \"memory/demo\") if _, err := os.Stat(memory); os.IsnotExist(err) { must(os.Mkdir(memory, 0755)) } //Establecemos limite y metemos al proceso dentro del grupo de procesos must(ioutil.WriteFile(filepath.Join(pids, \"pids.max\"), []byte(\"10\"), 0700)) must(ioutil.WriteFile(filepath.Join(pids, \"cgroup.procs\"), []byte(strconv.Itoa(os.Getpid())), 0700)) must(ioutil.WriteFile(filepath.Join(memory, \"memory.limit_in_bytes\"), []byte(\"2M\"), 0700)) must(ioutil.WriteFile(filepath.Join(memory, \"cgroup.procs\"), []byte(strconv.Itoa(os.Getpid())), 0700)) } S\u00f3lo hace falta llamar a esta funci\u00f3n desde el principio de la funci\u00f3n child . Anexo: mejora con pivot_root C\u00d3DIGO COMPLETO package main import ( \"fmt\" \"os\" \"os/exec\" \"syscall\" \"io/ioutil\" \"strconv\" \"path/filepath\" ) func main() { switch os.Args[1] { case \"run\": run() case \"child\": child() default: panic(\"\u00bfArgumento Invalido?\") } } func run() { fmt.Printf(\"Corriendo '%v' con User ID %d en PID %d \\n\", os.Args[2:], os.Getuid(), os.Getpid()) cmd := exec.Command(\"/proc/self/exe\", append([]string{\"child\"}, os.Args[2:]...)...) cmd.Stdin = os.Stdin cmd.Stdout= os.Stdout cmd.Stderr = os.Stderr cmd.SysProcAttr = &syscall.SysProcAttr{ Cloneflags: syscall.CLONE_NEWUTS | syscall.CLONE_NEWUSER | syscall.CLONE_NEWNS | syscall.CLONE_NEWPID, UidMappings: []syscall.SysProcIDMap{ { ContainerID: 0, HostID: os.Getuid(), Size: 1, }, }, GidMappings: []syscall.SysProcIDMap{ { ContainerID: 0, HostID: os.Getgid(), Size: 1, }, }, } must(cmd.Run()) } func child() { fmt.Printf(\"Corriendo '%v' con User ID %d en PID %d \\n\", os.Args[2:], os.Getuid(), os.Getpid()) cg() must(syscall.Sethostname([]byte(\"container\"))) pivot() must(syscall.Mount(\"proc\", \"proc\", \"proc\", 0, \"\")) cmd := exec.Command(os.Args[2], os.Args[3:]...) cmd.Stdin = os.Stdin cmd.Stdout = os.Stdout cmd.Stderr = os.Stderr must(syscall.Unmount(\".old_root\", syscall.MNT_DETACH)) must(os.Remove(\".old_root\")) defer func() { must(syscall.Unmount(\"proc\", 0)) }() must(cmd.Run()) } func cg() { cgroups := \"/sys/fs/cgroup\" pids := filepath.Join(cgroups, \"pids/demo\") if _, err := os.Stat(pids); os.IsNotExist(err) { must(os.Mkdir(pids, 0755)) } memory := filepath.Join(cgroups, \"memory/demo\") if _, err := os.Stat(memory); os.IsNotExist(err) { must(os.Mkdir(memory, 0755)) } must(ioutil.WriteFile(filepath.Join(pids, \"pids.max\"), []byte(\"22\"), 0700)) must(ioutil.WriteFile(filepath.Join(pids, \"cgroup.procs\"), []byte(strconv.Itoa(os.Getpid())), 0700)) must(ioutil.WriteFile(filepath.Join(memory, \"memory.limit_in_bytes\"), []byte(\"2M\"), 0700)) must(ioutil.WriteFile(filepath.Join(memory, \"cgroup.procs\"), []byte(strconv.Itoa(os.Getpid())), 0700)) } func pivot() { must(syscall.Mount(\"alpinefs\", \"alpinefs\", \"\", syscall.MS_BIND|syscall.MS_REC, \"\")) if _, err := os.Stat(\"alpinefs/.old_root\"); os.IsNotExist(err) { must(os.Mkdir(\"alpinefs/.old_root\", 0700)) } must(syscall.PivotRoot(\"alpinefs\", \"alpinefs/.old_root\")) must(os.Chdir(\"/\")) } func must(err error) { if err != nil { panic(err) } }","title":"Tutorial"},{"location":"#tutorial-ontenedor-en-go","text":"Warning Es muy recomendable utilizar una MV para realizar los siguientes pasos ya que pueden provocar problemas en el sistema si no se realizan correctamente. Nuestro objetivo es que, al acabar este tutorial, tengamos un programa que sea capaz de crear un proceso y aislarlo con namespaces y cgroups . De hecho, intentaremos que la interacci\u00f3n con \u00e9ste sea muy parecida a la que tendr\u00edamos cuando ejecutamos un contenedor Docker: # Nosotros vamos a ejecutarlo as\u00ed: root@bar:~$ go run contenedor.go run <command> <args> # Una ejecuci\u00f3n en Docker ser\u00eda algo de este estilo: root@bar:~$ docker run <image> <command> <args> Cabe destacar que es necesario que todos los ficheros est\u00e9n en una carpeta cuyo grupo y usuario pertenezcan a root , as\u00ed como realizar todos los comandos con privilegios de root.","title":"Tutorial ontenedor en Go"},{"location":"#paso-1-creacion-del-codigo-base","text":"El primer paso consiste en escribir las primeras dos funciones : main , que simplemente comprobar\u00e1 que se ha ejecutado el comando correcto en terminal y run , que imprimir\u00e1 en pantalla los datos del proceso y ejecutar\u00e1 otro nuevo. package main import ( \"fmt\" \"os\" \"os/exec\" ) func main() { switch os.Args[1] { case \"run\": run() default: panic(\"\u00bfArgumento Invalido?\") } } func run() { fmt.Printf(\"Corriendo '%v' con User ID %d en PID %d \\n\", os.Args[2:], os.Getuid(), os.Getpid()) cmd := exec.Command(os.Args[2], os.Args[3:]...) cmd.Stdin = os.Stdin cmd.Stdout = os.Stdout cmd.Stderr = os.Stderr cmd.Run() } Ahora puedes probar a ejecutar la instrucci\u00f3n go run contenedor.go run ps a y comprobar que se existen dos procesos: el contenedor.go y el ps a que le hemos indicado que ejecute dentro del \"pre-contenedor\". Explicaci\u00f3n La funci\u00f3n `run` simplemente imprime por pantalla informaci\u00f3n \u00fatil sobre el proceso que estamos ejecutando y que, m\u00e1s adelante, crear\u00e1 el contenedor. De momento, lo \u00fanico que estamos haciendo es indicarle que queremos ejecutar un comando con la funci\u00f3n `Command` del paquete [`exec`](https://golang.org/pkg/os/exec/) indic\u00e1ndole los argumentos. Este comando devuelve una estructura del tipo `Cmd` en la que tenemos que especificarle el _Stdin_ _Stdout_ y _Stderr_. Tambi\u00e9n podemos ejecutar otros comandos dentro del contenedor, como `go run contenedor.go run /bin/bash`, en cuyo caso se abrir\u00e1 una nueva terminal.","title":"Paso 1: Creaci\u00f3n del c\u00f3digo base"},{"location":"#paso-2-aislando-con-namespace-uts-hostname","text":"Este namespace permite cambiar tanto el hostname como el domain-name del contenedor sin que afecte a estos campos del host. Para lograr este aislamiento debemos a\u00f1adir las siguientes l\u00edneas , adem\u00e1s de importar el paquete necesario syscall : cmd.SysProcAttr = &syscall.SysProcAttr{ Cloneflags: syscall.CLONE_NEWUTS, } Con estos cambios lograremos que ,al iniciar el contenedor con go run contenedor.go run /bin/bash , podamos cambiar los el hostname dentro del contenedor y que, al salir del contenedor (saliendo del bash con un exit ) no haya cambiado en el host. C\u00f3digo completo hasta ahora. package main import ( \"fmt\" \"os\" \"os/exec\" \"syscall\" ) func main() { switch os.Args[1] { case \"run\": run() default: panic(\"\u00bfArgumento Invalido?\") } } func run() { fmt.Printf(\"Corriendo '%v' con User ID %d en PID %d \\n\", os.Args[2:], os.Getuid(), os.Getpid()) cmd := exec.Command(os.Args[2], os.Args[3:]...) cmd.Stdin = os.Stdin cmd.Stdout = os.Stdout cmd.Stderr = os.Stderr cmd.SysProcAttr = &syscall.SysProcAttr{ Cloneflags: syscall.CLONE_NEWUTS, } cmd.Run() }","title":"Paso 2: Aislando con Namespace UTS (Hostname)"},{"location":"#paso-3-aislando-con-namespace-user-username","text":"Con la inclusi\u00f3n de este namespace vamos a separar las tablas de UID y GID entre el host y el contenedor , de tal forma que dentro del contenedor no haya los mismos usuarios que fuera. Para crear el nuevo namespace simplemente es necesario a\u00f1adir una flag m\u00e1s al c\u00f3digo: cmd.SysProcAttr = &syscall.SysProcAttr{ Cloneflags: syscall.CLONE_NEWUTS | syscall.CLONE_NEWUSER, } El problema es que ahora mismo, cuando ejecutamos el contenedor, nos informa que el proceso que lo llama tiene UID 0 pero si comprobamos el usuario que se nos asign\u00f3 en la nueva tabla de UID nos asigna un usuario \"aleatorio\": root@bar:~$ go run contenedor.go run /bin/bash Corriendo '[/bin/bash]' con User ID 0 en PID 2792 root@bar:~$ id uid=65534(nobody) gid=65534(nogroup) groups=65534(nogroup) As\u00ed que le vamos a indicar que mapee el usuario fuera del contenedor (UID 0) con el que queramos dentro : cmd.SysProcAttr = &syscall.SysProcAttr{ Cloneflags: syscall.CLONE_NEWUTS | syscall.CLONE_NEWUSER, UidMappings: []syscall.SysProcIDMap{ { ContainerID: 0, // UID dentro del container HostID: os.Getuid(), // UID en el host Size: 1, // Quiero mapear solo unuser }, }, GidMappings: []syscall.SysProcIDMap{ { ContainerID: 0, HostID: os.Getgid(), Size: 1, }, }, } C\u00f3digo completo hasta ahora. package main import ( \"fmt\" \"os\" \"os/exec\" \"syscall\" ) func main() { switch os.Args[1] { case \"run\": run() default: panic(\"\u00bfArgumento Invalido?\") } } func run() { fmt.Printf(\"Corriendo '%v' con User ID %d en PID %d \\n\", os.Args[2:], os.Getuid(), os.Getpid()) cmd := exec.Command(os.Args[2], os.Args[3:]...) cmd.Stdin = os.Stdin cmd.Stdout = os.Stdout cmd.Stderr = os.Stderr cmd.SysProcAttr = &syscall.SysProcAttr{ Cloneflags: syscall.CLONE_NEWUTS | syscall.CLONE_NEWUSER, UidMappings: []syscall.SysProcIDMap{ { ContainerID: 0, // UID dentro del container HostID: os.Getuid(), // UID en el host Size: 1, // Quiero mapear solo unuser }, }, GidMappings: []syscall.SysProcIDMap{ { ContainerID: 0, HostID: os.Getpid(), Size: 1, }, }, } cmd.Run() }","title":"Paso 3: Aislando con Namespace USER (username)"},{"location":"#paso-4-aislando-con-namespace-ns-mount","text":"Este fue el primer Namespace que se incluy\u00f3 en el kernel de Linux y uno de los m\u00e1s sencillos: simplemente aisla los puntos de montaje. De tal forma que podemos esconder los montajes del host en el contenedor y viceversa . Para ver los puntos de montaje usados en cada una de las m\u00e1quinas con el comando mount . Para a\u00f1adir esta caracter\u00edstica debemos incluir la flag apropiada: cmd.SysProcAttr = &syscall.SysProcAttr{ Cloneflags: syscall.CLONE_NEWUTS | syscall.CLONE_NEWNS | syscall.CLONE_NEWUSER, {...} } C\u00f3digo completo hasta ahora. package main import ( \"fmt\" \"os\" \"os/exec\" \"syscall\" ) func main() { switch os.Args[1] { case \"run\": run() default: panic(\"\u00bfArgumento Invalido?\") } } func run() { fmt.Printf(\"Corriendo '%v' con User ID %d en PID %d \\n\", os.Args[2:], os.Getuid(), os.Getpid()) cmd := exec.Command(os.Args[2], os.Args[3:]...) cmd.Stdin = os.Stdin cmd.Stdout = os.Stdout cmd.Stderr = os.Stderr cmd.SysProcAttr = &syscall.SysProcAttr{ Cloneflags: syscall.CLONE_NEWUTS | syscall.CLONE_ syscall.CLONE_NEWUSER, UidMappings: []syscall.SysProcIDMap{ { ContainerID: 0, // UID dentro del container HostID: os.Getuid(), // UID en el host Size: 1, // Quiero mapear solo unuser }, }, GidMappings: []syscall.SysProcIDMap{ { ContainerID: 0, HostID: os.Getpid(), Size: 1, }, }, } cmd.Run() }","title":"Paso 4: Aislando con Namespace NS (Mount)"},{"location":"#paso-5-aislando-con-namespace-pid","text":"El PID namespace permite separar los \u00e1rboles de procesos, de tal forma que dentro del contenedor no se pueden ver los procesos del host . Para a\u00f1adir este namespace simplemente incluimos la flag apropiada: cmd.SysProcAttr = &syscall.SysProcAttr{ Cloneflags: syscall.CLONE_NEWUTS | syscall.CLONE_NEWUSER | syscall.CLONE_NEWNS | syscall.CLONE_NEWPID, } Sin embargo, cuando ejecutamos un ps a seguimos pudiendo ver los mismos procesos de antes. Explicaci\u00f3n: Mount Namespace no a\u00edsla los procesos. Es importante saber que **_/proc_** es un pseudo-filesystem montado por el sistema operativo por defecto donde se muestra la informaci\u00f3n sobre los procesos. Cuando hacemos un **_ps a_**, lo que est\u00e1 pasando realmente es que esta instrucci\u00f3n consulta los datos del directorio anteriormente nombrado. La soluci\u00f3n es asignar un nuevo /proc en la ra\u00edz del contenedor. Para ello necesitamos un nuevo root filesystem como Alpine (que continene \u00fanicamente los archivos necesarios para que funcione un contenedor).","title":"Paso 5: Aislando con Namespace PID"},{"location":"#paso-6-anadiendo-un-filesystem-para-el-contenedor","text":"Para realizar este paso necesitamos descargar el mini-root de Alpine. Lo descomprimimos y lo llamamos, por ejemplo, alpinefs y le cambiamos el usuario con chown root alpinefs/ .","title":"Paso 6: A\u00f1adiendo un Filesystem para el contenedor"},{"location":"#montamos-nuestro-propio-proc","text":"Necesitamos un nuevo directorio proc para que el comando ps a pueda acceder a \u00e9l para acceder a la informaci\u00f3n de los procesos del contnedor. Explicaci\u00f3n: directorio /proc Otra cosa que se podr\u00eda intuir es que es necesario a\u00f1adir el _Namespace NS (de Mount)_ para aislar ambos directorios. Pero no, este \u00faltimo comentario es falso pese a que existan muchas referencias en la red a que es completamente necesario: cuando un proceso como `ps` quiere comprobar los procesos activos en `/proc` lo que hace es ir directamente a ese archivo. Nuestro proceso, tanto con el _Namespace NS_ como sin \u00e9l, va a seguir mirando los procesos en la carpeta `/proc`, es decir, la que est\u00e1 justo debajo del directorio ra\u00edz y no en la del nuevo _root filesystem_ de alpine. As\u00ed que podr\u00edamos montar nuestro nuevo `proc/` sin el _Namespace NS_. La soluci\u00f3n de que se muestren \u00fanicamente los procesos activos de nuestro contenedor se divide en dos pasos, pero antes, debemos cambiar un poco la forma en la que hab\u00edamos planteado el programa en un principio. Ahora, en vez de ejecutar desde la funci\u00f3n run la instrucci\u00f3n indicada en los par\u00e1metros, vamos a duplicar el proceso actual llamando a /proc/self/exe para que esta segunda vez cambie el flujo de ejecuci\u00f3n y no pase por la funci\u00f3n run , sino por la funci\u00f3n child . cmd := exec.Command (\"/proc/self/exe\", append([]string {\"child\"}, os.Args[2:]...)...) De esta forma, habr\u00eda otra funci\u00f3n dentro del programa que se ejecutar\u00eda la segunda vez, donde implementamos la soluci\u00f3n a nuestro \u00faltimo problema: Hacer la nueva ra\u00edz de nuestro contenedor la ra\u00edz del filesystem que acabamos de descargar ( alpinefs/ ) para que al acceder a /proc est\u00e9 accediendo al nuevo y no al del Host. Esto se puede hacer tanto con la llamada al sistema chroot o pivot_root . La segunda opci\u00f3n es m\u00e1s segura, aunque m\u00e1s complicada. Por lo tanto, para evitar aumentar demasiado la complejidad se utilizar\u00e1 el primer m\u00e9todo (anexando el segundo al final del tutorial). Montar el filesystem proc para que el sistema pueda utilizarlo para almacenar informaci\u00f3n sobre los procesos. func child() { fmt.Printf(\"Running '%v' as user %d in PID %d \\n\", os.Args[2:], os.Getuid(), os.Getpid()) must(syscall.Chroot(\"alpinefs/\")) must(os.Chdir(\"/\")) must(syscall.Mount(\"proc\", \"proc\", \"proc\", 0, \"\")) cmd := exec.Command(os.Args[2], os.Args[3:]...) cmd.Stdin = os.Stdin cmd.Stdout = os.Stdout cmd.Stderr = os.Stderr defer func() { must(syscall.Unmount(\"proc\", 0)) }() must(cmd.Run()) } Explicaci\u00f3n: \u00bfpor qu\u00e9 crear una nueva funci\u00f3n? Ahora no s\u00f3lo vamos a a\u00f1adir _namespaces_ y ejecutar una instrucci\u00f3n sino que vamos a realizar otras acciones. Si cogemos el flujo de la funci\u00f3n `run` y realizamos las nuevas acciones despu\u00e9s de `cmd.Run()` no se estar\u00edan completando hasta que acabara esta \u00faltima orden. A su vez, si introducimos las acciones antes de `cmd.Run()` no se estar\u00edan creando a\u00fan los _namespaces_: es justo en mientras transcurre en `cmd.Run()` cuando queremos modificar el contenedor. Por eso una opci\u00f3n es obligar al proceso a llamarse a una copia de s\u00ed mismo y cambiar el flujo del programa a la nueva funci\u00f3n `child`. Cabe destacar que el _filesystem_ propuesto de Alpine no cuenta con Bash, as\u00ed que tendr\u00edamos que mandar ejecutar `/bin/sh` Por otro lado, es recomendable que a partir de ahora empezemos a manejar los errores que nos puedan aparecer: func must(err error) { if err != nil { panic(err) } } C\u00f3digo completo hasta ahora package main import ( \"fmt\" \"os\" \"os/exec\" \"syscall\" ) func main() { switch os.Args[1] { case \"run\": run() case \"child\": child() default: panic(\"\u00bfArgumento Invalido?\") } } func run() { fmt.Printf(\"Corriendo '%v' con User ID %d en PID %d \\n\", os.Args[2:], os.Getuid(), os.Getpid()) cmd := exec.Command(\"/proc/self/exe\", append([]string{\"child\"}, os.Args[2:]...)...) cmd.Stdin = os.Stdin cmd.Stdout= os.Stdout cmd.Stderr = os.Stderr cmd.SysProcAttr = &syscall.SysProcAttr{ Cloneflags: syscall.CLONE_NEWUTS | syscall.CLONE_NEWUSER | syscall.CLONE_NEWNS | syscall.CLONE_NEWPID, UidMappings: []syscall.SysProcIDMap{ { ContainerID: 0, HostID: os.Getuid(), Size: 1, }, }, GidMappings: []syscall.SysProcIDMap{ { ContainerID: 0, HostID: os.Getgid(), Size: 1, }, }, } must(cmd.Run()) } func child() { fmt.Printf(\"Corriendo '%v' con User ID %d en PID %d \\n\", os.Args[2:], os.Getuid(), os.Getpid()) must(syscall.Sethostname([]byte(\"container\"))) must(syscall.Chroot(\"alpinefs/\")) must(os.Chdir(\"/\")) must(syscall.Mount(\"proc\", \"proc\", \"proc\", 0, \"\")) cmd := exec.Command(os.Args[2], os.Args[3:]...) cmd.Stdin = os.Stdin cmd.Stdout = os.Stdout cmd.Stderr = os.Stderr defer func() { must(syscall.Unmount(\"proc\", 0)) }() must(cmd.Run()) } func must(err error) { if err != nil { panic(err) } } \u00bfQU\u00c9 HEMOS CONSEGUIDO HASTA AHORA? En estos momentos hemos conseguido introducir unos cuantos _namespaces_, al menos los m\u00e1s significativos para realizar en este tutorial. El hostname namespace se puede comprobar de esta forma: # Fuera del contenedor root@bar:~$ hostname host root@bar:~$ go run contenedor.go run /bin/sh Corriendo '[/bin/sh]' con User ID 0 en PID 72724 # Dentro del contenedor root@bar:~$ sethostname contenedor root@bar:~$ exit # Fuera del contenedor root@bar:~$ hostname host El user namespace lo hemos conseguido introducir a\u00f1adiendo los mapeos de usuario a root dentro del contenedor. Lo podemos comprobar de esta forma: # Fuera del contenedor root@bar:~$ go run contenedor.go run /bin/sh Corriendo '[/bin/sh]' con User ID 0 en PID 72724 # Dentro del contenedor root@bar:~$ id uid=0(root) gid=0(root) groups=0(root) El mount namespace se puede comprobar de una forma muy sencilla: # Fuera del contenedor root@bar:~$ mount ###### Aparecen muchos puntos de montaje usados por el host root@bar:~$ go run contenedor.go run /bin/sh Corriendo '[/bin/sh]' con User ID 0 en PID 72724 # Dentro del contenedor root@bar:~$ mount proc on /proc type proc (rw,relatime) El pid namespace lo podemos comprobar realizando las siguientes instrucciones: # Fuera del contenedor root@bar:~$ go run contenedor.go run /bin/sh Corriendo '[/bin/sh]' con User ID 0 en PID 72724 # Dentro del contenedor root@bar:~$ ps a PID USER TIME COMMAND 1 root 0:00 /proc/self/exe child /bin/sh 5 root 0:00 /bin/sh 11 root 0:00 ps a","title":"Montamos nuestro propio /proc"},{"location":"#anadiendo-cgroups-memoria-y-pid","text":"En este ejemplo a\u00f1adiremos un l\u00edmite al n\u00famero m\u00e1ximo de procesos en el cgroup (y, por lo tanto, en el contenedor) permitidos. Para ello necesitamos crear un nuevo directorio en /sys/fs/cgroup/pids/ . Al crear el directorio autom\u00e1ticamente el sistema a\u00f1ade los archivos necesarios para mostrar los datos del nuevo Cgroup y para modificar los l\u00edmites que se le quieran a\u00f1adir. En nuestro caso el grupo se llamar\u00e1 demo . Para modificar el n\u00famero m\u00e1ximo de procesos que se permite en el contenedor s\u00f3lo es necesario modificar el archivo donde se indica el n\u00famero (pondremos como m\u00e1ximo 12 procesos) y otro donde se introduce al proceso del contenedor en el grupo de control. Adem\u00e1s a\u00f1adiremos un n\u00famero m\u00e1ximo de bytes de memoria que se le asignan al contenedor, aunque esto es m\u00e1s complicado de comprobar que funciona correctamente, pero los pasos son los mismos que en el anterior caso. func cg() cgroups := \"/sys/fs/cgroup\" // Creando cgroup para PIDs pids := filepath.Join(cgroups, \"pids/demo\") if _, err := os.Stat(pids); os.IsNotExist(err) { must(os.Mkdir(pids, 0755)) } // Creando cgroup para PIDs memory := filepath.Join(cgroups, \"memory/demo\") if _, err := os.Stat(memory); os.IsnotExist(err) { must(os.Mkdir(memory, 0755)) } //Establecemos limite y metemos al proceso dentro del grupo de procesos must(ioutil.WriteFile(filepath.Join(pids, \"pids.max\"), []byte(\"10\"), 0700)) must(ioutil.WriteFile(filepath.Join(pids, \"cgroup.procs\"), []byte(strconv.Itoa(os.Getpid())), 0700)) must(ioutil.WriteFile(filepath.Join(memory, \"memory.limit_in_bytes\"), []byte(\"2M\"), 0700)) must(ioutil.WriteFile(filepath.Join(memory, \"cgroup.procs\"), []byte(strconv.Itoa(os.Getpid())), 0700)) } S\u00f3lo hace falta llamar a esta funci\u00f3n desde el principio de la funci\u00f3n child .","title":"A\u00f1adiendo Cgroups (memoria y PID)"},{"location":"#anexo-mejora-con-pivot_root","text":"C\u00d3DIGO COMPLETO package main import ( \"fmt\" \"os\" \"os/exec\" \"syscall\" \"io/ioutil\" \"strconv\" \"path/filepath\" ) func main() { switch os.Args[1] { case \"run\": run() case \"child\": child() default: panic(\"\u00bfArgumento Invalido?\") } } func run() { fmt.Printf(\"Corriendo '%v' con User ID %d en PID %d \\n\", os.Args[2:], os.Getuid(), os.Getpid()) cmd := exec.Command(\"/proc/self/exe\", append([]string{\"child\"}, os.Args[2:]...)...) cmd.Stdin = os.Stdin cmd.Stdout= os.Stdout cmd.Stderr = os.Stderr cmd.SysProcAttr = &syscall.SysProcAttr{ Cloneflags: syscall.CLONE_NEWUTS | syscall.CLONE_NEWUSER | syscall.CLONE_NEWNS | syscall.CLONE_NEWPID, UidMappings: []syscall.SysProcIDMap{ { ContainerID: 0, HostID: os.Getuid(), Size: 1, }, }, GidMappings: []syscall.SysProcIDMap{ { ContainerID: 0, HostID: os.Getgid(), Size: 1, }, }, } must(cmd.Run()) } func child() { fmt.Printf(\"Corriendo '%v' con User ID %d en PID %d \\n\", os.Args[2:], os.Getuid(), os.Getpid()) cg() must(syscall.Sethostname([]byte(\"container\"))) pivot() must(syscall.Mount(\"proc\", \"proc\", \"proc\", 0, \"\")) cmd := exec.Command(os.Args[2], os.Args[3:]...) cmd.Stdin = os.Stdin cmd.Stdout = os.Stdout cmd.Stderr = os.Stderr must(syscall.Unmount(\".old_root\", syscall.MNT_DETACH)) must(os.Remove(\".old_root\")) defer func() { must(syscall.Unmount(\"proc\", 0)) }() must(cmd.Run()) } func cg() { cgroups := \"/sys/fs/cgroup\" pids := filepath.Join(cgroups, \"pids/demo\") if _, err := os.Stat(pids); os.IsNotExist(err) { must(os.Mkdir(pids, 0755)) } memory := filepath.Join(cgroups, \"memory/demo\") if _, err := os.Stat(memory); os.IsNotExist(err) { must(os.Mkdir(memory, 0755)) } must(ioutil.WriteFile(filepath.Join(pids, \"pids.max\"), []byte(\"22\"), 0700)) must(ioutil.WriteFile(filepath.Join(pids, \"cgroup.procs\"), []byte(strconv.Itoa(os.Getpid())), 0700)) must(ioutil.WriteFile(filepath.Join(memory, \"memory.limit_in_bytes\"), []byte(\"2M\"), 0700)) must(ioutil.WriteFile(filepath.Join(memory, \"cgroup.procs\"), []byte(strconv.Itoa(os.Getpid())), 0700)) } func pivot() { must(syscall.Mount(\"alpinefs\", \"alpinefs\", \"\", syscall.MS_BIND|syscall.MS_REC, \"\")) if _, err := os.Stat(\"alpinefs/.old_root\"); os.IsNotExist(err) { must(os.Mkdir(\"alpinefs/.old_root\", 0700)) } must(syscall.PivotRoot(\"alpinefs\", \"alpinefs/.old_root\")) must(os.Chdir(\"/\")) } func must(err error) { if err != nil { panic(err) } }","title":"Anexo: mejora con pivot_root"},{"location":"prueba/","text":"Esto es una prueba esto es una prueba","title":"Prueba"},{"location":"prueba/#esto-es-una-prueba","text":"esto es una prueba","title":"Esto es una prueba"}]}