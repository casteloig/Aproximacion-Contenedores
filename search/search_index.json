{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Una aproximaci\u00f3n a los contenedores \u00bfQu\u00e9 es un contenedor? La virtualizaci\u00f3n es un proceso mediante el cual un software es usado para crear una abstracci\u00f3n sobre unos recursos, dando la sensaci\u00f3n de que los elementos hardware se dividen en varias computadores virtuales. Existen dos tipos t\u00e9cnicas principales de virtualizaci\u00f3n: M\u00e1quinas virtuales. Contenedores (virtualizaci\u00f3n ligera). Definici\u00f3n Un contenedor es un l\u00edmite l\u00f3gico que se crea dentro de un sistema operativo proporcionado por el aislamiento de recursos hardware. La caracter\u00edstica principal es que en esta t\u00e9cnica se utilizan herramientas que proporciona el Linux Kernel (como cgroups y namespaces ). Diferencia entre MV y contenedores Diferencia infraestructura: VM y contenedor Un contenedor es una forma de virtualizaci\u00f3n ligera . Normalmente envuelve a un peque\u00f1o grupo de procesos . Los contenedores comparten el kernel con el host. Dentro del contendor se encuentra \u00fanicamente el c\u00f3digo, librer\u00edas y ejecutables estrictamente necesarios . Usos principales Microservicios : los contenedores son ligeros y envuelven servicios muy peque\u00f1os , lo que los hace muy aptos para su uso en microservicios. DevOps + CI/CD : facilita el ciclo _\"build, test and deploy\". Cloud : los contenedores pueden funcionar de forma consistente en pr\u00e1cticamente cualquier lugar . Ventajas principales Rapidez y ligereza . Portabilidad e independencia de plataformas . Escalabilidad . Desventajas principales Seguridad : el aislamiento entre contenedores y el host es menor: puede provocar vulnerabilidades. Monitorizaci\u00f3n : existen varias capas que monitorizar aunque s\u00f3lo se tenga una aplicaci\u00f3n en un contenedor. Complejidad a gran escala . Historia de contenedores Chroot (1979) chroot es una llamada al sistema que permite cambiar el directorio raiz de un proceso y de sus hijos a un nuevo lugar dentro del sistema de archivos. Esto hace que un grupo de procesos tengan una visi\u00f3n limitada del almacenamiento del sistema. El principal problema de chroot es que los procesos con permisos de root se pueden saltar el aislamiento con facilidad. FreeBSD Jails (2000) Fue el primer \"pseudo-contenedor\" y el impulsor de las tecnolog\u00edas de los contenedores que existen hoy en d\u00eda. Su objetivo era \"confinar el root omnipotente\" , que da nombre al documento donde se presenta la herramienta. Las Jails dan uso a chroot a\u00f1adiendo nuevos mecanismos existentes en el sistema operativo. En cada jail los procesos pueden manipular \u00fanicamente los servicios y archivos a los que se le da acceso (por ello se le dio el nombre de jail : c\u00e1rcel en ingl\u00e9s, como si los procesos estuvieran en prisi\u00f3n). El administrador del sistema puede separar el sistema en varias celdas asignando un superusuario a cada una sin perder el control del sistema completo. Para mantener la seguridad deseada se desactivaron ciertas llamadas al sistema (para evitar, por ejemplo, el spoofing ), aunque esto impida utilizar ciertas instrucciones comunes como el comando ping . Por \u00faltimo, cada celda tiene sus propios UID y GID : un mismo usuario en una celda puede corresponderse con otro usuario en distinta celda. Solaris Zones (2004) Los creadores de esta tecnolog\u00eda no s\u00f3lo buscaban mantener la seguridad , sino tambi\u00e9n mejorar el uso de recursos a gran escala . De hecho, se pretend\u00eda dar soporte a aplicaciones comerciales potencialmente escalables. El objetivo era lograr que los administradores necesitaran pocos minutos para configurar y lanzar una nueva zone : el sistema se encargar\u00eda de crearla autom\u00e1ticamente a\u00f1adiendo los l\u00edmites en recursos compartidos que se consum\u00edan (inicialmente s\u00f3lo CPU). El administrador puede configurar las propiedades de las zones en tiempo real o mediante scripts. Existen dos tipos de zones : Global zone : es la zone por defecto que tiene control sobre todos los procesos. Siempre existe aunque no se haya creado ninguna manualmente. Non-global zone : son las zones configuradas desde la global. Algo a tener en cuenta es que las Zones se preocupan por mantener ciertas utilidades sin dejar a un lado la seguridad (por ejemplo, permite utilizar el comando ping a diferencia de las jails ). Cgroups y Namespaces (2006-2007) En el 2006 se propuso un framework que agrupa procesos y aprovecha los mecanismos de control existentes del kernel . El objetivo era que los usuarios se centren en el controlador de recursos y se abstraigan de c\u00f3mo los procesos son gestionados y monitorizados. Este mecanismo en un principio se llamaba process containers pero se cambi\u00f3 el nombre a cgroups para diferenciarlo de los contenedores que conocemos hoy en d\u00eda. Por otro lado, en el 2002 se cre\u00f3 el primer namespace , el mount namespace . Aunque fue m\u00e1s adelante a partir del a\u00f1o 2007 cuando se comenz\u00f3 a ver el potencial que pod\u00edan tener junto a otras funcionalidades como los cgroups , as\u00ed que se empezaron a desarrollar nuevos namespaces . En la actualidad existen ocho. LXC (2008) Los LXC se podr\u00edan considerar los primeros contenedores tal y como conocemos el concepto hoy en d\u00eda: fue la primera tecnolog\u00eda en aplicar los dos elementos principales de los contenedores: cgroups y namespaces . Permite al usuario comunicarse con las facilidades que ofrecen las funcionalidades del kernel mediante una interfaz en l\u00ednea de comandos . Sin embargo, no es una herramienta apropiada para realizar tareas de gesti\u00f3n de contenedores en un alto nivel. LMCTFY y Docker (2013) LMCTFY (Let Me Containerize That For You) fue la versi\u00f3n open-source del stack de Google a los contenedores de Linux. Su desarrollo finaliz\u00f3 en 2015 y Google comenz\u00f3 a transferir parte de la implementaci\u00f3n a libcontainer ahora mismo es una parte fundamental del stack de Docker y forma parte de OCI. Por otro lado, Docker supuso un despunte en la popularidad de los contenedores en el a\u00f1o de su salida y el crecimiento de ambos conceptos han ido de la mano desde entonces siendo hoy en d\u00eda l\u00edder en este \u00e1mbito . En sus inicios utilizaba LXC, pero m\u00e1s tarde lo sustituy\u00f3 por su propia librer\u00eda libcontainer . OCI (2015) OCI (Open Container Initiative) es un proyecto de la Linux Foundation cuyo objetivo es dise\u00f1ar un est\u00e1ndar abierto para la virtualizaci\u00f3n basada en contenedores . Fue establecida en 2015 por Docker y otros l\u00edderes de la industria. Despu\u00e9s del lanzamiento de Docker, surgi\u00f3 una comunidad alrededor de los contenedores. Sin embargo, con el paso del tiempo fueron apareciendo nuevas tecnolog\u00edas y herramientas que satisfac\u00edan las neceseidades que iban surgiendo. Este fue el motivo principal por el que surgi\u00f3 este est\u00e1ndar. Actualmente, OCI define dos especificaciones, aunque hablaremos m\u00e1s tarde de ellas en este documento * OJOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO * * Otras tecnolog\u00edas A lo largo de las dos \u00faltimas d\u00e9cadas han ido surgiendo otras tecnolog\u00edas de virtualizaci\u00f3n de sistema operativo, pero han sido menos importantes para el ecosistema de los contenedores que las anteriormente mencionadas. Entre ellas podemos encontrar Linux VServer (2001), OpenVZ (2005), Warden (2011), Singularity (2015) o Podman (2018). Arquitectura de los contenedores Generalizaci\u00f3n de la arquitectura de los contenedores a partir de la arquitectura de Docker","title":"Home"},{"location":"#una-aproximacion-a-los-contenedores","text":"","title":"Una aproximaci\u00f3n a los contenedores"},{"location":"#que-es-un-contenedor","text":"La virtualizaci\u00f3n es un proceso mediante el cual un software es usado para crear una abstracci\u00f3n sobre unos recursos, dando la sensaci\u00f3n de que los elementos hardware se dividen en varias computadores virtuales. Existen dos tipos t\u00e9cnicas principales de virtualizaci\u00f3n: M\u00e1quinas virtuales. Contenedores (virtualizaci\u00f3n ligera). Definici\u00f3n Un contenedor es un l\u00edmite l\u00f3gico que se crea dentro de un sistema operativo proporcionado por el aislamiento de recursos hardware. La caracter\u00edstica principal es que en esta t\u00e9cnica se utilizan herramientas que proporciona el Linux Kernel (como cgroups y namespaces ).","title":"\u00bfQu\u00e9 es un contenedor?"},{"location":"#diferencia-entre-mv-y-contenedores","text":"Diferencia infraestructura: VM y contenedor Un contenedor es una forma de virtualizaci\u00f3n ligera . Normalmente envuelve a un peque\u00f1o grupo de procesos . Los contenedores comparten el kernel con el host. Dentro del contendor se encuentra \u00fanicamente el c\u00f3digo, librer\u00edas y ejecutables estrictamente necesarios . Usos principales Microservicios : los contenedores son ligeros y envuelven servicios muy peque\u00f1os , lo que los hace muy aptos para su uso en microservicios. DevOps + CI/CD : facilita el ciclo _\"build, test and deploy\". Cloud : los contenedores pueden funcionar de forma consistente en pr\u00e1cticamente cualquier lugar . Ventajas principales Rapidez y ligereza . Portabilidad e independencia de plataformas . Escalabilidad . Desventajas principales Seguridad : el aislamiento entre contenedores y el host es menor: puede provocar vulnerabilidades. Monitorizaci\u00f3n : existen varias capas que monitorizar aunque s\u00f3lo se tenga una aplicaci\u00f3n en un contenedor. Complejidad a gran escala .","title":"Diferencia entre MV y contenedores"},{"location":"#historia-de-contenedores","text":"","title":"Historia de contenedores"},{"location":"#chroot-1979","text":"chroot es una llamada al sistema que permite cambiar el directorio raiz de un proceso y de sus hijos a un nuevo lugar dentro del sistema de archivos. Esto hace que un grupo de procesos tengan una visi\u00f3n limitada del almacenamiento del sistema. El principal problema de chroot es que los procesos con permisos de root se pueden saltar el aislamiento con facilidad.","title":"Chroot (1979)"},{"location":"#freebsd-jails-2000","text":"Fue el primer \"pseudo-contenedor\" y el impulsor de las tecnolog\u00edas de los contenedores que existen hoy en d\u00eda. Su objetivo era \"confinar el root omnipotente\" , que da nombre al documento donde se presenta la herramienta. Las Jails dan uso a chroot a\u00f1adiendo nuevos mecanismos existentes en el sistema operativo. En cada jail los procesos pueden manipular \u00fanicamente los servicios y archivos a los que se le da acceso (por ello se le dio el nombre de jail : c\u00e1rcel en ingl\u00e9s, como si los procesos estuvieran en prisi\u00f3n). El administrador del sistema puede separar el sistema en varias celdas asignando un superusuario a cada una sin perder el control del sistema completo. Para mantener la seguridad deseada se desactivaron ciertas llamadas al sistema (para evitar, por ejemplo, el spoofing ), aunque esto impida utilizar ciertas instrucciones comunes como el comando ping . Por \u00faltimo, cada celda tiene sus propios UID y GID : un mismo usuario en una celda puede corresponderse con otro usuario en distinta celda.","title":"FreeBSD Jails (2000)"},{"location":"#solaris-zones-2004","text":"Los creadores de esta tecnolog\u00eda no s\u00f3lo buscaban mantener la seguridad , sino tambi\u00e9n mejorar el uso de recursos a gran escala . De hecho, se pretend\u00eda dar soporte a aplicaciones comerciales potencialmente escalables. El objetivo era lograr que los administradores necesitaran pocos minutos para configurar y lanzar una nueva zone : el sistema se encargar\u00eda de crearla autom\u00e1ticamente a\u00f1adiendo los l\u00edmites en recursos compartidos que se consum\u00edan (inicialmente s\u00f3lo CPU). El administrador puede configurar las propiedades de las zones en tiempo real o mediante scripts. Existen dos tipos de zones : Global zone : es la zone por defecto que tiene control sobre todos los procesos. Siempre existe aunque no se haya creado ninguna manualmente. Non-global zone : son las zones configuradas desde la global. Algo a tener en cuenta es que las Zones se preocupan por mantener ciertas utilidades sin dejar a un lado la seguridad (por ejemplo, permite utilizar el comando ping a diferencia de las jails ).","title":"Solaris Zones (2004)"},{"location":"#cgroups-y-namespaces-2006-2007","text":"En el 2006 se propuso un framework que agrupa procesos y aprovecha los mecanismos de control existentes del kernel . El objetivo era que los usuarios se centren en el controlador de recursos y se abstraigan de c\u00f3mo los procesos son gestionados y monitorizados. Este mecanismo en un principio se llamaba process containers pero se cambi\u00f3 el nombre a cgroups para diferenciarlo de los contenedores que conocemos hoy en d\u00eda. Por otro lado, en el 2002 se cre\u00f3 el primer namespace , el mount namespace . Aunque fue m\u00e1s adelante a partir del a\u00f1o 2007 cuando se comenz\u00f3 a ver el potencial que pod\u00edan tener junto a otras funcionalidades como los cgroups , as\u00ed que se empezaron a desarrollar nuevos namespaces . En la actualidad existen ocho.","title":"Cgroups y Namespaces (2006-2007)"},{"location":"#lxc-2008","text":"Los LXC se podr\u00edan considerar los primeros contenedores tal y como conocemos el concepto hoy en d\u00eda: fue la primera tecnolog\u00eda en aplicar los dos elementos principales de los contenedores: cgroups y namespaces . Permite al usuario comunicarse con las facilidades que ofrecen las funcionalidades del kernel mediante una interfaz en l\u00ednea de comandos . Sin embargo, no es una herramienta apropiada para realizar tareas de gesti\u00f3n de contenedores en un alto nivel.","title":"LXC (2008)"},{"location":"#lmctfy-y-docker-2013","text":"LMCTFY (Let Me Containerize That For You) fue la versi\u00f3n open-source del stack de Google a los contenedores de Linux. Su desarrollo finaliz\u00f3 en 2015 y Google comenz\u00f3 a transferir parte de la implementaci\u00f3n a libcontainer ahora mismo es una parte fundamental del stack de Docker y forma parte de OCI. Por otro lado, Docker supuso un despunte en la popularidad de los contenedores en el a\u00f1o de su salida y el crecimiento de ambos conceptos han ido de la mano desde entonces siendo hoy en d\u00eda l\u00edder en este \u00e1mbito . En sus inicios utilizaba LXC, pero m\u00e1s tarde lo sustituy\u00f3 por su propia librer\u00eda libcontainer .","title":"LMCTFY y Docker (2013)"},{"location":"#oci-2015","text":"OCI (Open Container Initiative) es un proyecto de la Linux Foundation cuyo objetivo es dise\u00f1ar un est\u00e1ndar abierto para la virtualizaci\u00f3n basada en contenedores . Fue establecida en 2015 por Docker y otros l\u00edderes de la industria. Despu\u00e9s del lanzamiento de Docker, surgi\u00f3 una comunidad alrededor de los contenedores. Sin embargo, con el paso del tiempo fueron apareciendo nuevas tecnolog\u00edas y herramientas que satisfac\u00edan las neceseidades que iban surgiendo. Este fue el motivo principal por el que surgi\u00f3 este est\u00e1ndar. Actualmente, OCI define dos especificaciones, aunque hablaremos m\u00e1s tarde de ellas en este documento * OJOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO * *","title":"OCI (2015)"},{"location":"#otras-tecnologias","text":"A lo largo de las dos \u00faltimas d\u00e9cadas han ido surgiendo otras tecnolog\u00edas de virtualizaci\u00f3n de sistema operativo, pero han sido menos importantes para el ecosistema de los contenedores que las anteriormente mencionadas. Entre ellas podemos encontrar Linux VServer (2001), OpenVZ (2005), Warden (2011), Singularity (2015) o Podman (2018).","title":"Otras tecnolog\u00edas"},{"location":"#arquitectura-de-los-contenedores","text":"Generalizaci\u00f3n de la arquitectura de los contenedores a partir de la arquitectura de Docker","title":"Arquitectura de los contenedores"},{"location":"tutoriales/contenedorbash/","text":"Contenedor en Bash CUIDADO Es muy recomendable utilizar una MV para realizar los siguientes pasos ya que pueden provocar problemas en el sistema si no se realizan correctamente. Namespaces Para crear un contenedor en terminal necesitamos muchas menos instrucciones que para crearlo en Go: contamos con comandos que facilitan enormemente la tarea. En el siguiente ejemplo se crear\u00e1 lo mismo que en el tutorial de Go pero en tan s\u00f3lo unas pocas l\u00edneas. Para el caso de los namespaces simplemente necesitamos utilizar la orden unshare : en este caso crearemos los correspondientes a --mount , --pid , --uts y --user . Adem\u00e1s, vamos a especificar con --fork que la terminal que va a abrir el programa sea un hijo del proceso unshare (es \u00fatil precisamente porque hemos creado un nuevo Namespace PID ). Con --map-root-user ahorramos todas las l\u00edneas que escrib\u00edamos en Go para hacer que el usuario del nuevo Namespace USER sea root. Por \u00faltimo, podemos ahorrar realizar el pivot_root del que ya hemos hablado anteriormente con la opci\u00f3n root=[direcci\u00f3n] . Por otro lado, es importante acordarse de montar el nuevo pseudo-filesystem de /proc . root@bar~$ unshare --mount --pid --uts --user --fork --map-root-user --root = alpinefs /bin/sh root@bar~$ mount -t proc proc proc root@bar~$ hostname demo Cgroups En el caso de los grupos de control, tiene la misma dificultad que en el ejemplo en Go: simplemente hay que crear los directorios correspondientes para cada tipo de Cgroup , eso s\u00ed, desde una terminal con root en el Host, ya que tenemos que introducir el PID en los correspondientes cgroup.procs del Namespace USER superior (es decir, el que vemos desde el host). root @ bar ~$ ps aux | grep / sh root 2552 pts / 0 00 : 13 / bin / sh root @ bar ~$ mkdir / sys / fs / cgroup / pids / demo root @ bar ~$ mkdir / sys / fs / cgroup / memory / demo root @ bar ~$ echo 20 / sys / fs / cgroup / pids / demo / pids . max root @ bar ~$ echo 2552 / sys / fs / cgroup / pids / demo / cgroup . procs root @ bar ~$ echo \"2M\" / sys / fs / cgroup / memory / demo / memory . limit_in_bytes root @ bar ~$ echo 2552 / sys / fs / cgroup / memory / demo / cgroup . procs","title":"Tutorial Bash"},{"location":"tutoriales/contenedorbash/#contenedor-en-bash","text":"CUIDADO Es muy recomendable utilizar una MV para realizar los siguientes pasos ya que pueden provocar problemas en el sistema si no se realizan correctamente.","title":"Contenedor en Bash"},{"location":"tutoriales/contenedorbash/#namespaces","text":"Para crear un contenedor en terminal necesitamos muchas menos instrucciones que para crearlo en Go: contamos con comandos que facilitan enormemente la tarea. En el siguiente ejemplo se crear\u00e1 lo mismo que en el tutorial de Go pero en tan s\u00f3lo unas pocas l\u00edneas. Para el caso de los namespaces simplemente necesitamos utilizar la orden unshare : en este caso crearemos los correspondientes a --mount , --pid , --uts y --user . Adem\u00e1s, vamos a especificar con --fork que la terminal que va a abrir el programa sea un hijo del proceso unshare (es \u00fatil precisamente porque hemos creado un nuevo Namespace PID ). Con --map-root-user ahorramos todas las l\u00edneas que escrib\u00edamos en Go para hacer que el usuario del nuevo Namespace USER sea root. Por \u00faltimo, podemos ahorrar realizar el pivot_root del que ya hemos hablado anteriormente con la opci\u00f3n root=[direcci\u00f3n] . Por otro lado, es importante acordarse de montar el nuevo pseudo-filesystem de /proc . root@bar~$ unshare --mount --pid --uts --user --fork --map-root-user --root = alpinefs /bin/sh root@bar~$ mount -t proc proc proc root@bar~$ hostname demo","title":"Namespaces"},{"location":"tutoriales/contenedorbash/#cgroups","text":"En el caso de los grupos de control, tiene la misma dificultad que en el ejemplo en Go: simplemente hay que crear los directorios correspondientes para cada tipo de Cgroup , eso s\u00ed, desde una terminal con root en el Host, ya que tenemos que introducir el PID en los correspondientes cgroup.procs del Namespace USER superior (es decir, el que vemos desde el host). root @ bar ~$ ps aux | grep / sh root 2552 pts / 0 00 : 13 / bin / sh root @ bar ~$ mkdir / sys / fs / cgroup / pids / demo root @ bar ~$ mkdir / sys / fs / cgroup / memory / demo root @ bar ~$ echo 20 / sys / fs / cgroup / pids / demo / pids . max root @ bar ~$ echo 2552 / sys / fs / cgroup / pids / demo / cgroup . procs root @ bar ~$ echo \"2M\" / sys / fs / cgroup / memory / demo / memory . limit_in_bytes root @ bar ~$ echo 2552 / sys / fs / cgroup / memory / demo / cgroup . procs","title":"Cgroups"},{"location":"tutoriales/contenedorgo/","text":"Tutorial ontenedor en Go CUIDADO Es muy recomendable utilizar una MV para realizar los siguientes pasos ya que pueden provocar problemas en el sistema si no se realizan correctamente. Nuestro objetivo es que, al acabar este tutorial, tengamos un programa que sea capaz de crear un proceso y aislarlo con namespaces y cgroups . De hecho, intentaremos que la interacci\u00f3n con \u00e9ste sea muy parecida a la que tendr\u00edamos cuando ejecutamos un contenedor Docker: # Nosotros vamos a ejecutarlo as\u00ed: root@bar:~$ go run contenedor.go run <command> <args> # Una ejecuci\u00f3n en Docker ser\u00eda algo de este estilo: root@bar:~$ docker run <image> <command> <args> Cabe destacar que es necesario que todos los ficheros est\u00e9n en una carpeta cuyo grupo y usuario pertenezca a root , as\u00ed como realizar todos los comandos con privilegios de root. Paso 1: Creaci\u00f3n del c\u00f3digo base El primer paso consiste en escribir las primeras dos funciones : main , que simplemente comprobar\u00e1 que se ha ejecutado el comando correcto en terminal y run , que imprimir\u00e1 en pantalla los datos del proceso y ejecutar\u00e1 otro nuevo que le indiquemos en par\u00e1metro. package main import ( \"fmt\" \"os\" \"os/exec\" ) func main () { switch os . Args [ 1 ] { case \"run\" : run () default : panic ( \"\u00bfArgumento Invalido?\" ) } } func run () { fmt . Printf ( \"Corriendo '%v' con User ID %d en PID %d \\n\" , os . Args [ 2 :], os . Getuid (), os . Getpid ()) cmd := exec . Command ( os . Args [ 2 ], os . Args [ 3 :] ... ) cmd . Stdin = os . Stdin cmd . Stdout = os . Stdout cmd . Stderr = os . Stderr cmd . Run () } Ahora puedes probar a ejecutar la instrucci\u00f3n go run contenedor.go run ps a y comprobar que se existen dos procesos: el contenedor.go y el ps a que le hemos indicado que ejecute dentro del \"pre-contenedor\". Explicaci\u00f3n La funci\u00f3n run simplemente imprime por pantalla informaci\u00f3n \u00fatil sobre el proceso que estamos ejecutando y que, m\u00e1s adelante, crear\u00e1 el contenedor. De momento, lo \u00fanico que estamos haciendo es indicarle que queremos ejecutar un comando con la funci\u00f3n Command del paquete exec indic\u00e1ndole los argumentos. Este comando devuelve una estructura del tipo Cmd en la que tenemos que especificarle el Stdin Stdout y Stderr . Tambi\u00e9n podemos ejecutar otros comandos dentro del contenedor, como go run contenedor.go run /bin/bash , en cuyo caso se abrir\u00e1 una nueva terminal. Paso 2: Aislando con Namespace UTS (Hostname) Este namespace permite cambiar tanto el hostname como el domain-name del contenedor sin que afecte a estos campos del host. Para lograr este aislamiento debemos a\u00f1adir las siguientes l\u00edneas , adem\u00e1s de importar el paquete necesario syscall : cmd . SysProcAttr = & syscall . SysProcAttr { Cloneflags : syscall . CLONE_NEWUTS , } Con estos cambios lograremos que, al iniciar el contenedor con go run contenedor.go run /bin/bash , podamos cambiar el hostname dentro del contenedor y que, al salir del mismo (saliendo del bash con un exit ) no haya cambiado en el host. C\u00f3digo completo hasta ahora package main import ( \"fmt\" \"os\" \"os/exec\" \"syscall\" ) func main () { switch os . Args [ 1 ] { case \"run\" : run () default : panic ( \"\u00bfArgumento Invalido?\" ) } } func run () { fmt . Printf ( \"Corriendo '%v' con User ID %d en PID %d \\n\" , os . Args [ 2 :], os . Getuid (), os . Getpid ()) cmd := exec . Command ( os . Args [ 2 ], os . Args [ 3 :] ... ) cmd . Stdin = os . Stdin cmd . Stdout = os . Stdout cmd . Stderr = os . Stderr cmd . SysProcAttr = & syscall . SysProcAttr { Cloneflags : syscall . CLONE_NEWUTS , } cmd . Run () } Paso 3: Aislando con Namespace USER (username) Con la inclusi\u00f3n de este namespace vamos a separar las tablas de UID y GID entre el host y el contenedor , de tal forma que dentro del contenedor no haya los mismos usuarios que fuera. Para crear el nuevo namespace simplemente es necesario a\u00f1adir una flag m\u00e1s al c\u00f3digo: cmd . SysProcAttr = & syscall . SysProcAttr { Cloneflags : syscall . CLONE_NEWUTS | syscall . CLONE_NEWUSER , } El problema es que ahora mismo, cuando ejecutamos el contenedor, nos informa que el proceso que lo llama tiene UID 0 pero si comprobamos el usuario que se nos asign\u00f3 en la nueva tabla de UID (o sea, en la tabla del contenedor) es un usuario \"aleatorio\": root@bar:~$ go run contenedor.go run /bin/bash Corriendo '[/bin/bash]' con User ID 0 en PID 2792 root@bar:~$ id uid=65534(nobody) gid=65534(nogroup) groups=65534(nogroup) As\u00ed que le vamos a indicar que mapee el usuario de fuera del contenedor (UID 0) con el que queramos dentro : cmd . SysProcAttr = & syscall . SysProcAttr { Cloneflags : syscall . CLONE_NEWUTS | syscall . CLONE_NEWUSER , UidMappings : [] syscall . SysProcIDMap { { ContainerID : 0 , // UID dentro del contenedor HostID : os . Getuid (), // UID en el host Size : 1 , // Quiero mapear solo un usuario }, }, GidMappings : [] syscall . SysProcIDMap { { ContainerID : 0 , HostID : os . Getgid (), Size : 1 , }, }, } C\u00f3digo completo hasta ahora package main import ( \"fmt\" \"os\" \"os/exec\" \"syscall\" ) func main () { switch os . Args [ 1 ] { case \"run\" : run () default : panic ( \"\u00bfArgumento Invalido?\" ) } } func run () { fmt . Printf ( \"Corriendo '%v' con User ID %d en PID %d \\n\" , os . Args [ 2 :], os . Getuid (), os . Getpid ()) cmd := exec . Command ( os . Args [ 2 ], os . Args [ 3 :] ... ) cmd . Stdin = os . Stdin cmd . Stdout = os . Stdout cmd . Stderr = os . Stderr cmd . SysProcAttr = & syscall . SysProcAttr { Cloneflags : syscall . CLONE_NEWUTS | syscall . CLONE_NEWUSER , UidMappings : [] syscall . SysProcIDMap { { ContainerID : 0 , // UID dentro del container HostID : os . Getuid (), // UID en el host Size : 1 , // Quiero mapear solo unuser }, }, GidMappings : [] syscall . SysProcIDMap { { ContainerID : 0 , HostID : os . Getpid (), Size : 1 , }, }, } cmd . Run () } Paso 4: Aislando con Namespace NS (Mount) Este fue el primer Namespace que se incluy\u00f3 en el kernel de Linux y uno de los m\u00e1s sencillos: simplemente aisla los puntos de montaje. De esta forma podemos esconder los mounts entre el host y el contenedor y viceversa . Para ver los puntos de montaje usados en cada una de las m\u00e1quinas con el comando mount . Para a\u00f1adir esta caracter\u00edstica debemos incluir la flag apropiada: cmd . SysProcAttr = & syscall . SysProcAttr { Cloneflags : syscall . CLONE_NEWUTS | syscall . CLONE_NEWNS | syscall . CLONE_NEWUSER , { ... } } C\u00f3digo completo hasta ahora package main import ( \"fmt\" \"os\" \"os/exec\" \"syscall\" ) func main () { switch os . Args [ 1 ] { case \"run\" : run () default : panic ( \"\u00bfArgumento Invalido?\" ) } } func run () { fmt . Printf ( \"Corriendo '%v' con User ID %d en PID %d \\n\" , os . Args [ 2 :], os . Getuid (), os . Getpid ()) cmd := exec . Command ( os . Args [ 2 ], os . Args [ 3 :] ... ) cmd . Stdin = os . Stdin cmd . Stdout = os . Stdout cmd . Stderr = os . Stderr cmd . SysProcAttr = & syscall . SysProcAttr { Cloneflags : syscall . CLONE_NEWUTS | syscall . CLONE_ syscall . CLONE_NEWUSER , UidMappings : [] syscall . SysProcIDMap { { ContainerID : 0 , // UID dentro del container HostID : os . Getuid (), // UID en el host Size : 1 , // Quiero mapear solo unuser }, }, GidMappings : [] syscall . SysProcIDMap { { ContainerID : 0 , HostID : os . Getpid (), Size : 1 , }, }, } cmd . Run () } Paso 5: Aislando con Namespace PID El PID namespace permite separar los \u00e1rboles de procesos, de tal forma que dentro del contenedor no se pueden ver los procesos del host . Para a\u00f1adir este namespace simplemente incluimos la flag apropiada: cmd . SysProcAttr = & syscall . SysProcAttr { Cloneflags : syscall . CLONE_NEWUTS | syscall . CLONE_NEWUSER | syscall . CLONE_NEWNS | syscall . CLONE_NEWPID , { ... } } Sin embargo, cuando ejecutamos un ps a seguimos pudiendo ver los mismos procesos de antes. Explicaci\u00f3n: Mount Namespace no a\u00edsla los procesos Es importante saber que /proc es un pseudo-filesystem montado por el sistema operativo por defecto donde se muestra la informaci\u00f3n sobre los procesos. Cuando hacemos un ps a , lo que est\u00e1 pasando realmente es que esta instrucci\u00f3n est\u00e1 consultando los datos del directorio anteriormente nombrado. La soluci\u00f3n es asignar un nuevo /proc en la ra\u00edz del contenedor. Para ello necesitamos un nuevo root filesystem como Alpine (que continene \u00fanicamente los archivos necesarios para que funcione un contenedor). Paso 6: A\u00f1adiendo un Filesystem para el contenedor Para realizar este paso necesitamos descargar el mini-root de Alpine. Lo descomprimimos y lo llamamos, por ejemplo, alpinefs y le cambiamos el usuario con chown root alpinefs/ . Montamos nuestro propio /proc Necesitamos un nuevo directorio proc para que el comando ps a pueda acceder a \u00e9l para acceder a la informaci\u00f3n de los procesos del contnedor. Explicaci\u00f3n: directorio /proc Otra cosa que se podr\u00eda intuir es que es necesario a\u00f1adir el Namespace NS (de Mount) para aislar ambos directorios. Pero no, este \u00faltimo comentario es falso pese a que existan muchas referencias en la red a que es completamente necesario: cuando un proceso como ps quiere comprobar los procesos activos en /proc lo que hace es ir directamente a ese archivo. Nuestro proceso, tanto con el Namespace NS como sin \u00e9l, va a seguir mirando los procesos en la carpeta /proc , es decir, la que est\u00e1 justo debajo del directorio ra\u00edz y no en la del nuevo root filesystem de alpine. As\u00ed que podr\u00edamos montar nuestro nuevo proc/ sin el Namespace NS . La soluci\u00f3n de que se muestren \u00fanicamente los procesos activos de nuestro contenedor se divide en dos pasos, pero antes, debemos cambiar un poco la forma en la que hab\u00edamos planteado el programa en un principio. Ahora, en vez de ejecutar desde la funci\u00f3n run la instrucci\u00f3n indicada en los par\u00e1metros, vamos a duplicar el proceso actual llamando a /proc/self/exe para que en esta segunda ejecuci\u00f3n se cambie el flujo del programa y no pase por la funci\u00f3n run , sino por la funci\u00f3n child . cmd := exec . Command ( \"/proc/self/exe\" , append ([] string { \"child\" }, os . Args [ 2 :] ... ) ... ) De esta forma, habr\u00eda otra funci\u00f3n dentro del programa que se ejecutar\u00eda la segunda vez, donde implementamos la soluci\u00f3n a nuestro \u00faltimo problema: Hacer la nueva ra\u00edz de nuestro contenedor la ra\u00edz del filesystem que acabamos de descargar ( alpinefs/ ) para que al acceder a /proc est\u00e9 accediendo al nuevo y no al del Host. Esto se puede hacer tanto con la llamada al sistema chroot o pivot_root . La segunda opci\u00f3n es m\u00e1s segura, aunque m\u00e1s complicada. Por lo tanto, para evitar aumentar demasiado la complejidad se utilizar\u00e1 el primer m\u00e9todo (anexando el segundo al final del tutorial). Montar el filesystem proc para que el sistema pueda utilizarlo para almacenar informaci\u00f3n sobre los procesos. func child () { fmt . Printf ( \"Running '%v' as user %d in PID %d \\n\" , os . Args [ 2 :], os . Getuid (), os . Getpid ()) must ( syscall . Chroot ( \"alpinefs/\" )) must ( os . Chdir ( \"/\" )) must ( syscall . Mount ( \"proc\" , \"proc\" , \"proc\" , 0 , \"\" )) cmd := exec . Command ( os . Args [ 2 ], os . Args [ 3 :] ... ) cmd . Stdin = os . Stdin cmd . Stdout = os . Stdout cmd . Stderr = os . Stderr defer func () { must ( syscall . Unmount ( \"proc\" , 0 )) }() must ( cmd . Run ()) } Explicaci\u00f3n: \u00bfpor qu\u00e9 crear una nueva funci\u00f3n? Ahora no s\u00f3lo vamos a a\u00f1adir namespaces y ejecutar una instrucci\u00f3n sino que vamos a realizar otras acciones. Si cogemos el flujo de la funci\u00f3n run y realizamos las nuevas acciones despu\u00e9s de cmd.Run() no se estar\u00edan completando hasta que acabara esta \u00faltima orden. A su vez, si introducimos las acciones antes de cmd.Run() no se habr\u00edan creado a\u00fan los_namespaces: es justo mientras transcurre en cmd.Run() cuando queremos modificar el contenedor. Por eso una opci\u00f3n es obligar al proceso a llamarse a una copia de s\u00ed mismo y cambiar el flujo del programa a la nueva funci\u00f3n child . Cabe destacar que el filesystem propuesto de Alpine no cuenta con Bash, as\u00ed que tendr\u00edamos que mandar ejecutar /bin/sh Por otro lado, es recomendable que a partir de ahora empezemos a manejar los errores que nos puedan aparecer: func must ( err error ) { if err != nil { panic ( err ) } } C\u00f3digo completo hasta ahora package main import ( \"fmt\" \"os\" \"os/exec\" \"syscall\" ) func main () { switch os . Args [ 1 ] { case \"run\" : run () case \"child\" : child () default : panic ( \"\u00bfArgumento Invalido?\" ) } } func run () { fmt . Printf ( \"Corriendo '%v' con User ID %d en PID %d \\n\" , os . Args [ 2 :], os . Getuid (), os . Getpid ()) cmd := exec . Command ( \"/proc/self/exe\" , append ([] string { \"child\" }, os . Args [ 2 :] ... ) ... ) cmd . Stdin = os . Stdin cmd . Stdout = os . Stdout cmd . Stderr = os . Stderr cmd . SysProcAttr = & syscall . SysProcAttr { Cloneflags : syscall . CLONE_NEWUTS | syscall . CLONE_NEWUSER | syscall . CLONE_NEWNS | syscall . CLONE_NEWPID , UidMappings : [] syscall . SysProcIDMap { { ContainerID : 0 , HostID : os . Getuid (), Size : 1 , }, }, GidMappings : [] syscall . SysProcIDMap { { ContainerID : 0 , HostID : os . Getgid (), Size : 1 , }, }, } must ( cmd . Run ()) } func child () { fmt . Printf ( \"Corriendo '%v' con User ID %d en PID %d \\n\" , os . Args [ 2 :], os . Getuid (), os . Getpid ()) must ( syscall . Sethostname ([] byte ( \"container\" ))) must ( syscall . Chroot ( \"alpinefs/\" )) must ( os . Chdir ( \"/\" )) must ( syscall . Mount ( \"proc\" , \"proc\" , \"proc\" , 0 , \"\" )) cmd := exec . Command ( os . Args [ 2 ], os . Args [ 3 :] ... ) cmd . Stdin = os . Stdin cmd . Stdout = os . Stdout cmd . Stderr = os . Stderr defer func () { must ( syscall . Unmount ( \"proc\" , 0 )) }() must ( cmd . Run ()) } func must ( err error ) { if err != nil { panic ( err ) } } \u00bfQU\u00c9 HEMOS CONSEGUIDO HASTA AHORA? En estos momentos hemos conseguido introducir unos cuantos namespaces , al menos los m\u00e1s significativos para realizar en este tutorial. El hostname namespace se puede comprobar de esta forma: # Fuera del contenedor root@bar:~$ hostname host root@bar:~$ go run contenedor.go run /bin/sh Corriendo '[/bin/sh]' con User ID 0 en PID 72724 # Dentro del contenedor root@bar:~$ sethostname contenedor root@bar:~$ exit # Fuera del contenedor root@bar:~$ hostname host El user namespace lo hemos conseguido introducir a\u00f1adiendo los mapeos de usuario a root dentro del contenedor. Lo podemos comprobar de esta forma: # Fuera del contenedor root@bar:~$ go run contenedor.go run /bin/sh Corriendo '[/bin/sh]' con User ID 0 en PID 72724 # Dentro del contenedor root@bar:~$ id uid=0(root) gid=0(root) groups=0(root) El mount namespace se puede comprobar de una forma muy sencilla: # Fuera del contenedor root@bar:~$ mount # ##### Aparecen muchos puntos de montaje usados por el host root@bar:~$ go run contenedor.go run /bin/sh Corriendo '[/bin/sh]' con User ID 0 en PID 72724 # Dentro del contenedor root@bar:~$ mount proc on /proc type proc (rw,relatime) El pid namespace lo podemos comprobar realizando las siguientes instrucciones: # Fuera del contenedor root@bar:~$ go run contenedor.go run /bin/sh Corriendo '[/bin/sh]' con User ID 0 en PID 72724 # Dentro del contenedor root@bar:~$ ps a PID USER TIME COMMAND 1 root 0:00 /proc/self/exe child /bin/sh 5 root 0:00 /bin/sh 11 root 0:00 ps a A\u00f1adiendo Cgroups (memoria y PID) En este ejemplo a\u00f1adiremos un l\u00edmite al n\u00famero m\u00e1ximo de procesos en el cgroup (y, por lo tanto, en el contenedor) permitidos. Para ello necesitamos crear un nuevo directorio en /sys/fs/cgroup/pids/ . Al crear el directorio autom\u00e1ticamente el sistema a\u00f1ade los archivos necesarios para mostrar los datos del nuevo Cgroup y para modificar los l\u00edmites que se le quieran a\u00f1adir. En nuestro caso el grupo se llamar\u00e1 demo . Para modificar el n\u00famero m\u00e1ximo de procesos que se permite en el contenedor s\u00f3lo es necesario modificar el archivo donde se indica el n\u00famero (pondremos como m\u00e1ximo 12 procesos) y otro donde se introduce al proceso del contenedor en el grupo de control. Adem\u00e1s a\u00f1adiremos un n\u00famero m\u00e1ximo de bytes de memoria que se le asignan al contenedor, aunque esto es m\u00e1s complicado de comprobar que funciona correctamente, pero los pasos son los mismos que en el anterior caso. func cg () cgroups := \"/sys/fs/cgroup\" // Creando cgroup para PIDs pids := filepath . Join ( cgroups , \"pids/demo\" ) if _ , err := os . Stat ( pids ); os . IsNotExist ( err ) { must ( os . Mkdir ( pids , 0755 )) } // Creando cgroup para PIDs memory := filepath . Join ( cgroups , \"memory/demo\" ) if _ , err := os . Stat ( memory ); os . IsnotExist ( err ) { must ( os . Mkdir ( memory , 0755 )) } //Establecemos limite y metemos al proceso dentro del grupo de procesos must ( ioutil . WriteFile ( filepath . Join ( pids , \"pids.max\" ), [] byte ( \"10\" ), 0700 )) must ( ioutil . WriteFile ( filepath . Join ( pids , \"cgroup.procs\" ), [] byte ( strconv . Itoa ( os . Getpid ())), 0700 )) must ( ioutil . WriteFile ( filepath . Join ( memory , \"memory.limit_in_bytes\" ), [] byte ( \"2M\" ), 0700 )) must ( ioutil . WriteFile ( filepath . Join ( memory , \"cgroup.procs\" ), [] byte ( strconv . Itoa ( os . Getpid ())), 0700 )) } S\u00f3lo hace falta llamar a esta funci\u00f3n desde el principio de la funci\u00f3n child . Anexo: mejora con pivot_root Cuando se introdujo en el tutorial la llamada al sistema chroot se mencion\u00f3 la posibilidad de utilizar otra m\u00e1s segura: pivot_root . Aunque antiguamente, en los primeros contenedores, se utilizaba la primera opci\u00f3n, se ha llegado a la conclusi\u00f3n de que tiene varios fallos de seguridad que permiten \"salir o escapar\" del contenedor. pivot_root aprovecha el mount namespace ya que permite hacer unmount del antiguo root y no lo hace accesible en el namespace del contenedor. Si usamos \u00fanicamente chroot podemos acceder al Host con el siguiente comando: chroot /proc/1/root . Lo que hay que saber para poder usar pivot_root es que necesita dos argumentos, el primero es la direcci\u00f3n del nuevo directorio ra\u00edz (no viene en la documentaci\u00f3n pero debe estar montado sobre s\u00ed mismo con la opci\u00f3n bind ) y el segundo es la direcci\u00f3n donde se va a situar el antiguo directorio ra\u00edz. El c\u00f3digo completo del tutorial quedar\u00eda as\u00ed: C\u00d3DIGO COMPLETO package main import ( \"fmt\" \"os\" \"os/exec\" \"syscall\" \"io/ioutil\" \"strconv\" \"path/filepath\" ) func main () { switch os . Args [ 1 ] { case \"run\" : run () case \"child\" : child () default : panic ( \"\u00bfArgumento Invalido?\" ) } } func run () { fmt . Printf ( \"Corriendo '%v' con User ID %d en PID %d \\n\" , os . Args [ 2 :], os . Getuid (), os . Getpid ()) cmd := exec . Command ( \"/proc/self/exe\" , append ([] string { \"child\" }, os . Args [ 2 :] ... ) ... ) cmd . Stdin = os . Stdin cmd . Stdout = os . Stdout cmd . Stderr = os . Stderr cmd . SysProcAttr = & syscall . SysProcAttr { Cloneflags : syscall . CLONE_NEWUTS | syscall . CLONE_NEWUSER | syscall . CLONE_NEWNS | syscall . CLONE_NEWPID , UidMappings : [] syscall . SysProcIDMap { { ContainerID : 0 , HostID : os . Getuid (), Size : 1 , }, }, GidMappings : [] syscall . SysProcIDMap { { ContainerID : 0 , HostID : os . Getgid (), Size : 1 , }, }, } must ( cmd . Run ()) } func child () { fmt . Printf ( \"Corriendo '%v' con User ID %d en PID %d \\n\" , os . Args [ 2 :], os . Getuid (), os . Getpid ()) cg () must ( syscall . Sethostname ([] byte ( \"container\" ))) pivot () must ( syscall . Mount ( \"proc\" , \"proc\" , \"proc\" , 0 , \"\" )) cmd := exec . Command ( os . Args [ 2 ], os . Args [ 3 :] ... ) cmd . Stdin = os . Stdin cmd . Stdout = os . Stdout cmd . Stderr = os . Stderr must ( syscall . Unmount ( \".old_root\" , syscall . MNT_DETACH )) must ( os . Remove ( \".old_root\" )) defer func () { must ( syscall . Unmount ( \"proc\" , 0 )) }() must ( cmd . Run ()) } func cg () { cgroups := \"/sys/fs/cgroup\" pids := filepath . Join ( cgroups , \"pids/demo\" ) if _ , err := os . Stat ( pids ); os . IsNotExist ( err ) { must ( os . Mkdir ( pids , 0755 )) } memory := filepath . Join ( cgroups , \"memory/demo\" ) if _ , err := os . Stat ( memory ); os . IsNotExist ( err ) { must ( os . Mkdir ( memory , 0755 )) } must ( ioutil . WriteFile ( filepath . Join ( pids , \"pids.max\" ), [] byte ( \"22\" ), 0700 )) must ( ioutil . WriteFile ( filepath . Join ( pids , \"cgroup.procs\" ), [] byte ( strconv . Itoa ( os . Getpid ())), 0700 )) must ( ioutil . WriteFile ( filepath . Join ( memory , \"memory.limit_in_bytes\" ), [] byte ( \"2M\" ), 0700 )) must ( ioutil . WriteFile ( filepath . Join ( memory , \"cgroup.procs\" ), [] byte ( strconv . Itoa ( os . Getpid ())), 0700 )) } func pivot () { must ( syscall . Mount ( \"alpinefs\" , \"alpinefs\" , \"\" , syscall . MS_BIND | syscall . MS_REC , \"\" )) if _ , err := os . Stat ( \"alpinefs/.old_root\" ); os . IsNotExist ( err ) { must ( os . Mkdir ( \"alpinefs/.old_root\" , 0700 )) } must ( syscall . PivotRoot ( \"alpinefs\" , \"alpinefs/.old_root\" )) must ( os . Chdir ( \"/\" )) } func must ( err error ) { if err != nil { panic ( err ) } }","title":"Tutorial Go"},{"location":"tutoriales/contenedorgo/#tutorial-ontenedor-en-go","text":"CUIDADO Es muy recomendable utilizar una MV para realizar los siguientes pasos ya que pueden provocar problemas en el sistema si no se realizan correctamente. Nuestro objetivo es que, al acabar este tutorial, tengamos un programa que sea capaz de crear un proceso y aislarlo con namespaces y cgroups . De hecho, intentaremos que la interacci\u00f3n con \u00e9ste sea muy parecida a la que tendr\u00edamos cuando ejecutamos un contenedor Docker: # Nosotros vamos a ejecutarlo as\u00ed: root@bar:~$ go run contenedor.go run <command> <args> # Una ejecuci\u00f3n en Docker ser\u00eda algo de este estilo: root@bar:~$ docker run <image> <command> <args> Cabe destacar que es necesario que todos los ficheros est\u00e9n en una carpeta cuyo grupo y usuario pertenezca a root , as\u00ed como realizar todos los comandos con privilegios de root.","title":"Tutorial ontenedor en Go"},{"location":"tutoriales/contenedorgo/#paso-1-creacion-del-codigo-base","text":"El primer paso consiste en escribir las primeras dos funciones : main , que simplemente comprobar\u00e1 que se ha ejecutado el comando correcto en terminal y run , que imprimir\u00e1 en pantalla los datos del proceso y ejecutar\u00e1 otro nuevo que le indiquemos en par\u00e1metro. package main import ( \"fmt\" \"os\" \"os/exec\" ) func main () { switch os . Args [ 1 ] { case \"run\" : run () default : panic ( \"\u00bfArgumento Invalido?\" ) } } func run () { fmt . Printf ( \"Corriendo '%v' con User ID %d en PID %d \\n\" , os . Args [ 2 :], os . Getuid (), os . Getpid ()) cmd := exec . Command ( os . Args [ 2 ], os . Args [ 3 :] ... ) cmd . Stdin = os . Stdin cmd . Stdout = os . Stdout cmd . Stderr = os . Stderr cmd . Run () } Ahora puedes probar a ejecutar la instrucci\u00f3n go run contenedor.go run ps a y comprobar que se existen dos procesos: el contenedor.go y el ps a que le hemos indicado que ejecute dentro del \"pre-contenedor\". Explicaci\u00f3n La funci\u00f3n run simplemente imprime por pantalla informaci\u00f3n \u00fatil sobre el proceso que estamos ejecutando y que, m\u00e1s adelante, crear\u00e1 el contenedor. De momento, lo \u00fanico que estamos haciendo es indicarle que queremos ejecutar un comando con la funci\u00f3n Command del paquete exec indic\u00e1ndole los argumentos. Este comando devuelve una estructura del tipo Cmd en la que tenemos que especificarle el Stdin Stdout y Stderr . Tambi\u00e9n podemos ejecutar otros comandos dentro del contenedor, como go run contenedor.go run /bin/bash , en cuyo caso se abrir\u00e1 una nueva terminal.","title":"Paso 1: Creaci\u00f3n del c\u00f3digo base"},{"location":"tutoriales/contenedorgo/#paso-2-aislando-con-namespace-uts-hostname","text":"Este namespace permite cambiar tanto el hostname como el domain-name del contenedor sin que afecte a estos campos del host. Para lograr este aislamiento debemos a\u00f1adir las siguientes l\u00edneas , adem\u00e1s de importar el paquete necesario syscall : cmd . SysProcAttr = & syscall . SysProcAttr { Cloneflags : syscall . CLONE_NEWUTS , } Con estos cambios lograremos que, al iniciar el contenedor con go run contenedor.go run /bin/bash , podamos cambiar el hostname dentro del contenedor y que, al salir del mismo (saliendo del bash con un exit ) no haya cambiado en el host. C\u00f3digo completo hasta ahora package main import ( \"fmt\" \"os\" \"os/exec\" \"syscall\" ) func main () { switch os . Args [ 1 ] { case \"run\" : run () default : panic ( \"\u00bfArgumento Invalido?\" ) } } func run () { fmt . Printf ( \"Corriendo '%v' con User ID %d en PID %d \\n\" , os . Args [ 2 :], os . Getuid (), os . Getpid ()) cmd := exec . Command ( os . Args [ 2 ], os . Args [ 3 :] ... ) cmd . Stdin = os . Stdin cmd . Stdout = os . Stdout cmd . Stderr = os . Stderr cmd . SysProcAttr = & syscall . SysProcAttr { Cloneflags : syscall . CLONE_NEWUTS , } cmd . Run () }","title":"Paso 2: Aislando con Namespace UTS (Hostname)"},{"location":"tutoriales/contenedorgo/#paso-3-aislando-con-namespace-user-username","text":"Con la inclusi\u00f3n de este namespace vamos a separar las tablas de UID y GID entre el host y el contenedor , de tal forma que dentro del contenedor no haya los mismos usuarios que fuera. Para crear el nuevo namespace simplemente es necesario a\u00f1adir una flag m\u00e1s al c\u00f3digo: cmd . SysProcAttr = & syscall . SysProcAttr { Cloneflags : syscall . CLONE_NEWUTS | syscall . CLONE_NEWUSER , } El problema es que ahora mismo, cuando ejecutamos el contenedor, nos informa que el proceso que lo llama tiene UID 0 pero si comprobamos el usuario que se nos asign\u00f3 en la nueva tabla de UID (o sea, en la tabla del contenedor) es un usuario \"aleatorio\": root@bar:~$ go run contenedor.go run /bin/bash Corriendo '[/bin/bash]' con User ID 0 en PID 2792 root@bar:~$ id uid=65534(nobody) gid=65534(nogroup) groups=65534(nogroup) As\u00ed que le vamos a indicar que mapee el usuario de fuera del contenedor (UID 0) con el que queramos dentro : cmd . SysProcAttr = & syscall . SysProcAttr { Cloneflags : syscall . CLONE_NEWUTS | syscall . CLONE_NEWUSER , UidMappings : [] syscall . SysProcIDMap { { ContainerID : 0 , // UID dentro del contenedor HostID : os . Getuid (), // UID en el host Size : 1 , // Quiero mapear solo un usuario }, }, GidMappings : [] syscall . SysProcIDMap { { ContainerID : 0 , HostID : os . Getgid (), Size : 1 , }, }, } C\u00f3digo completo hasta ahora package main import ( \"fmt\" \"os\" \"os/exec\" \"syscall\" ) func main () { switch os . Args [ 1 ] { case \"run\" : run () default : panic ( \"\u00bfArgumento Invalido?\" ) } } func run () { fmt . Printf ( \"Corriendo '%v' con User ID %d en PID %d \\n\" , os . Args [ 2 :], os . Getuid (), os . Getpid ()) cmd := exec . Command ( os . Args [ 2 ], os . Args [ 3 :] ... ) cmd . Stdin = os . Stdin cmd . Stdout = os . Stdout cmd . Stderr = os . Stderr cmd . SysProcAttr = & syscall . SysProcAttr { Cloneflags : syscall . CLONE_NEWUTS | syscall . CLONE_NEWUSER , UidMappings : [] syscall . SysProcIDMap { { ContainerID : 0 , // UID dentro del container HostID : os . Getuid (), // UID en el host Size : 1 , // Quiero mapear solo unuser }, }, GidMappings : [] syscall . SysProcIDMap { { ContainerID : 0 , HostID : os . Getpid (), Size : 1 , }, }, } cmd . Run () }","title":"Paso 3: Aislando con Namespace USER (username)"},{"location":"tutoriales/contenedorgo/#paso-4-aislando-con-namespace-ns-mount","text":"Este fue el primer Namespace que se incluy\u00f3 en el kernel de Linux y uno de los m\u00e1s sencillos: simplemente aisla los puntos de montaje. De esta forma podemos esconder los mounts entre el host y el contenedor y viceversa . Para ver los puntos de montaje usados en cada una de las m\u00e1quinas con el comando mount . Para a\u00f1adir esta caracter\u00edstica debemos incluir la flag apropiada: cmd . SysProcAttr = & syscall . SysProcAttr { Cloneflags : syscall . CLONE_NEWUTS | syscall . CLONE_NEWNS | syscall . CLONE_NEWUSER , { ... } } C\u00f3digo completo hasta ahora package main import ( \"fmt\" \"os\" \"os/exec\" \"syscall\" ) func main () { switch os . Args [ 1 ] { case \"run\" : run () default : panic ( \"\u00bfArgumento Invalido?\" ) } } func run () { fmt . Printf ( \"Corriendo '%v' con User ID %d en PID %d \\n\" , os . Args [ 2 :], os . Getuid (), os . Getpid ()) cmd := exec . Command ( os . Args [ 2 ], os . Args [ 3 :] ... ) cmd . Stdin = os . Stdin cmd . Stdout = os . Stdout cmd . Stderr = os . Stderr cmd . SysProcAttr = & syscall . SysProcAttr { Cloneflags : syscall . CLONE_NEWUTS | syscall . CLONE_ syscall . CLONE_NEWUSER , UidMappings : [] syscall . SysProcIDMap { { ContainerID : 0 , // UID dentro del container HostID : os . Getuid (), // UID en el host Size : 1 , // Quiero mapear solo unuser }, }, GidMappings : [] syscall . SysProcIDMap { { ContainerID : 0 , HostID : os . Getpid (), Size : 1 , }, }, } cmd . Run () }","title":"Paso 4: Aislando con Namespace NS (Mount)"},{"location":"tutoriales/contenedorgo/#paso-5-aislando-con-namespace-pid","text":"El PID namespace permite separar los \u00e1rboles de procesos, de tal forma que dentro del contenedor no se pueden ver los procesos del host . Para a\u00f1adir este namespace simplemente incluimos la flag apropiada: cmd . SysProcAttr = & syscall . SysProcAttr { Cloneflags : syscall . CLONE_NEWUTS | syscall . CLONE_NEWUSER | syscall . CLONE_NEWNS | syscall . CLONE_NEWPID , { ... } } Sin embargo, cuando ejecutamos un ps a seguimos pudiendo ver los mismos procesos de antes. Explicaci\u00f3n: Mount Namespace no a\u00edsla los procesos Es importante saber que /proc es un pseudo-filesystem montado por el sistema operativo por defecto donde se muestra la informaci\u00f3n sobre los procesos. Cuando hacemos un ps a , lo que est\u00e1 pasando realmente es que esta instrucci\u00f3n est\u00e1 consultando los datos del directorio anteriormente nombrado. La soluci\u00f3n es asignar un nuevo /proc en la ra\u00edz del contenedor. Para ello necesitamos un nuevo root filesystem como Alpine (que continene \u00fanicamente los archivos necesarios para que funcione un contenedor).","title":"Paso 5: Aislando con Namespace PID"},{"location":"tutoriales/contenedorgo/#paso-6-anadiendo-un-filesystem-para-el-contenedor","text":"Para realizar este paso necesitamos descargar el mini-root de Alpine. Lo descomprimimos y lo llamamos, por ejemplo, alpinefs y le cambiamos el usuario con chown root alpinefs/ .","title":"Paso 6: A\u00f1adiendo un Filesystem para el contenedor"},{"location":"tutoriales/contenedorgo/#montamos-nuestro-propio-proc","text":"Necesitamos un nuevo directorio proc para que el comando ps a pueda acceder a \u00e9l para acceder a la informaci\u00f3n de los procesos del contnedor. Explicaci\u00f3n: directorio /proc Otra cosa que se podr\u00eda intuir es que es necesario a\u00f1adir el Namespace NS (de Mount) para aislar ambos directorios. Pero no, este \u00faltimo comentario es falso pese a que existan muchas referencias en la red a que es completamente necesario: cuando un proceso como ps quiere comprobar los procesos activos en /proc lo que hace es ir directamente a ese archivo. Nuestro proceso, tanto con el Namespace NS como sin \u00e9l, va a seguir mirando los procesos en la carpeta /proc , es decir, la que est\u00e1 justo debajo del directorio ra\u00edz y no en la del nuevo root filesystem de alpine. As\u00ed que podr\u00edamos montar nuestro nuevo proc/ sin el Namespace NS . La soluci\u00f3n de que se muestren \u00fanicamente los procesos activos de nuestro contenedor se divide en dos pasos, pero antes, debemos cambiar un poco la forma en la que hab\u00edamos planteado el programa en un principio. Ahora, en vez de ejecutar desde la funci\u00f3n run la instrucci\u00f3n indicada en los par\u00e1metros, vamos a duplicar el proceso actual llamando a /proc/self/exe para que en esta segunda ejecuci\u00f3n se cambie el flujo del programa y no pase por la funci\u00f3n run , sino por la funci\u00f3n child . cmd := exec . Command ( \"/proc/self/exe\" , append ([] string { \"child\" }, os . Args [ 2 :] ... ) ... ) De esta forma, habr\u00eda otra funci\u00f3n dentro del programa que se ejecutar\u00eda la segunda vez, donde implementamos la soluci\u00f3n a nuestro \u00faltimo problema: Hacer la nueva ra\u00edz de nuestro contenedor la ra\u00edz del filesystem que acabamos de descargar ( alpinefs/ ) para que al acceder a /proc est\u00e9 accediendo al nuevo y no al del Host. Esto se puede hacer tanto con la llamada al sistema chroot o pivot_root . La segunda opci\u00f3n es m\u00e1s segura, aunque m\u00e1s complicada. Por lo tanto, para evitar aumentar demasiado la complejidad se utilizar\u00e1 el primer m\u00e9todo (anexando el segundo al final del tutorial). Montar el filesystem proc para que el sistema pueda utilizarlo para almacenar informaci\u00f3n sobre los procesos. func child () { fmt . Printf ( \"Running '%v' as user %d in PID %d \\n\" , os . Args [ 2 :], os . Getuid (), os . Getpid ()) must ( syscall . Chroot ( \"alpinefs/\" )) must ( os . Chdir ( \"/\" )) must ( syscall . Mount ( \"proc\" , \"proc\" , \"proc\" , 0 , \"\" )) cmd := exec . Command ( os . Args [ 2 ], os . Args [ 3 :] ... ) cmd . Stdin = os . Stdin cmd . Stdout = os . Stdout cmd . Stderr = os . Stderr defer func () { must ( syscall . Unmount ( \"proc\" , 0 )) }() must ( cmd . Run ()) } Explicaci\u00f3n: \u00bfpor qu\u00e9 crear una nueva funci\u00f3n? Ahora no s\u00f3lo vamos a a\u00f1adir namespaces y ejecutar una instrucci\u00f3n sino que vamos a realizar otras acciones. Si cogemos el flujo de la funci\u00f3n run y realizamos las nuevas acciones despu\u00e9s de cmd.Run() no se estar\u00edan completando hasta que acabara esta \u00faltima orden. A su vez, si introducimos las acciones antes de cmd.Run() no se habr\u00edan creado a\u00fan los_namespaces: es justo mientras transcurre en cmd.Run() cuando queremos modificar el contenedor. Por eso una opci\u00f3n es obligar al proceso a llamarse a una copia de s\u00ed mismo y cambiar el flujo del programa a la nueva funci\u00f3n child . Cabe destacar que el filesystem propuesto de Alpine no cuenta con Bash, as\u00ed que tendr\u00edamos que mandar ejecutar /bin/sh Por otro lado, es recomendable que a partir de ahora empezemos a manejar los errores que nos puedan aparecer: func must ( err error ) { if err != nil { panic ( err ) } } C\u00f3digo completo hasta ahora package main import ( \"fmt\" \"os\" \"os/exec\" \"syscall\" ) func main () { switch os . Args [ 1 ] { case \"run\" : run () case \"child\" : child () default : panic ( \"\u00bfArgumento Invalido?\" ) } } func run () { fmt . Printf ( \"Corriendo '%v' con User ID %d en PID %d \\n\" , os . Args [ 2 :], os . Getuid (), os . Getpid ()) cmd := exec . Command ( \"/proc/self/exe\" , append ([] string { \"child\" }, os . Args [ 2 :] ... ) ... ) cmd . Stdin = os . Stdin cmd . Stdout = os . Stdout cmd . Stderr = os . Stderr cmd . SysProcAttr = & syscall . SysProcAttr { Cloneflags : syscall . CLONE_NEWUTS | syscall . CLONE_NEWUSER | syscall . CLONE_NEWNS | syscall . CLONE_NEWPID , UidMappings : [] syscall . SysProcIDMap { { ContainerID : 0 , HostID : os . Getuid (), Size : 1 , }, }, GidMappings : [] syscall . SysProcIDMap { { ContainerID : 0 , HostID : os . Getgid (), Size : 1 , }, }, } must ( cmd . Run ()) } func child () { fmt . Printf ( \"Corriendo '%v' con User ID %d en PID %d \\n\" , os . Args [ 2 :], os . Getuid (), os . Getpid ()) must ( syscall . Sethostname ([] byte ( \"container\" ))) must ( syscall . Chroot ( \"alpinefs/\" )) must ( os . Chdir ( \"/\" )) must ( syscall . Mount ( \"proc\" , \"proc\" , \"proc\" , 0 , \"\" )) cmd := exec . Command ( os . Args [ 2 ], os . Args [ 3 :] ... ) cmd . Stdin = os . Stdin cmd . Stdout = os . Stdout cmd . Stderr = os . Stderr defer func () { must ( syscall . Unmount ( \"proc\" , 0 )) }() must ( cmd . Run ()) } func must ( err error ) { if err != nil { panic ( err ) } } \u00bfQU\u00c9 HEMOS CONSEGUIDO HASTA AHORA? En estos momentos hemos conseguido introducir unos cuantos namespaces , al menos los m\u00e1s significativos para realizar en este tutorial. El hostname namespace se puede comprobar de esta forma: # Fuera del contenedor root@bar:~$ hostname host root@bar:~$ go run contenedor.go run /bin/sh Corriendo '[/bin/sh]' con User ID 0 en PID 72724 # Dentro del contenedor root@bar:~$ sethostname contenedor root@bar:~$ exit # Fuera del contenedor root@bar:~$ hostname host El user namespace lo hemos conseguido introducir a\u00f1adiendo los mapeos de usuario a root dentro del contenedor. Lo podemos comprobar de esta forma: # Fuera del contenedor root@bar:~$ go run contenedor.go run /bin/sh Corriendo '[/bin/sh]' con User ID 0 en PID 72724 # Dentro del contenedor root@bar:~$ id uid=0(root) gid=0(root) groups=0(root) El mount namespace se puede comprobar de una forma muy sencilla: # Fuera del contenedor root@bar:~$ mount # ##### Aparecen muchos puntos de montaje usados por el host root@bar:~$ go run contenedor.go run /bin/sh Corriendo '[/bin/sh]' con User ID 0 en PID 72724 # Dentro del contenedor root@bar:~$ mount proc on /proc type proc (rw,relatime) El pid namespace lo podemos comprobar realizando las siguientes instrucciones: # Fuera del contenedor root@bar:~$ go run contenedor.go run /bin/sh Corriendo '[/bin/sh]' con User ID 0 en PID 72724 # Dentro del contenedor root@bar:~$ ps a PID USER TIME COMMAND 1 root 0:00 /proc/self/exe child /bin/sh 5 root 0:00 /bin/sh 11 root 0:00 ps a","title":"Montamos nuestro propio /proc"},{"location":"tutoriales/contenedorgo/#anadiendo-cgroups-memoria-y-pid","text":"En este ejemplo a\u00f1adiremos un l\u00edmite al n\u00famero m\u00e1ximo de procesos en el cgroup (y, por lo tanto, en el contenedor) permitidos. Para ello necesitamos crear un nuevo directorio en /sys/fs/cgroup/pids/ . Al crear el directorio autom\u00e1ticamente el sistema a\u00f1ade los archivos necesarios para mostrar los datos del nuevo Cgroup y para modificar los l\u00edmites que se le quieran a\u00f1adir. En nuestro caso el grupo se llamar\u00e1 demo . Para modificar el n\u00famero m\u00e1ximo de procesos que se permite en el contenedor s\u00f3lo es necesario modificar el archivo donde se indica el n\u00famero (pondremos como m\u00e1ximo 12 procesos) y otro donde se introduce al proceso del contenedor en el grupo de control. Adem\u00e1s a\u00f1adiremos un n\u00famero m\u00e1ximo de bytes de memoria que se le asignan al contenedor, aunque esto es m\u00e1s complicado de comprobar que funciona correctamente, pero los pasos son los mismos que en el anterior caso. func cg () cgroups := \"/sys/fs/cgroup\" // Creando cgroup para PIDs pids := filepath . Join ( cgroups , \"pids/demo\" ) if _ , err := os . Stat ( pids ); os . IsNotExist ( err ) { must ( os . Mkdir ( pids , 0755 )) } // Creando cgroup para PIDs memory := filepath . Join ( cgroups , \"memory/demo\" ) if _ , err := os . Stat ( memory ); os . IsnotExist ( err ) { must ( os . Mkdir ( memory , 0755 )) } //Establecemos limite y metemos al proceso dentro del grupo de procesos must ( ioutil . WriteFile ( filepath . Join ( pids , \"pids.max\" ), [] byte ( \"10\" ), 0700 )) must ( ioutil . WriteFile ( filepath . Join ( pids , \"cgroup.procs\" ), [] byte ( strconv . Itoa ( os . Getpid ())), 0700 )) must ( ioutil . WriteFile ( filepath . Join ( memory , \"memory.limit_in_bytes\" ), [] byte ( \"2M\" ), 0700 )) must ( ioutil . WriteFile ( filepath . Join ( memory , \"cgroup.procs\" ), [] byte ( strconv . Itoa ( os . Getpid ())), 0700 )) } S\u00f3lo hace falta llamar a esta funci\u00f3n desde el principio de la funci\u00f3n child .","title":"A\u00f1adiendo Cgroups (memoria y PID)"},{"location":"tutoriales/contenedorgo/#anexo-mejora-con-pivot_root","text":"Cuando se introdujo en el tutorial la llamada al sistema chroot se mencion\u00f3 la posibilidad de utilizar otra m\u00e1s segura: pivot_root . Aunque antiguamente, en los primeros contenedores, se utilizaba la primera opci\u00f3n, se ha llegado a la conclusi\u00f3n de que tiene varios fallos de seguridad que permiten \"salir o escapar\" del contenedor. pivot_root aprovecha el mount namespace ya que permite hacer unmount del antiguo root y no lo hace accesible en el namespace del contenedor. Si usamos \u00fanicamente chroot podemos acceder al Host con el siguiente comando: chroot /proc/1/root . Lo que hay que saber para poder usar pivot_root es que necesita dos argumentos, el primero es la direcci\u00f3n del nuevo directorio ra\u00edz (no viene en la documentaci\u00f3n pero debe estar montado sobre s\u00ed mismo con la opci\u00f3n bind ) y el segundo es la direcci\u00f3n donde se va a situar el antiguo directorio ra\u00edz. El c\u00f3digo completo del tutorial quedar\u00eda as\u00ed: C\u00d3DIGO COMPLETO package main import ( \"fmt\" \"os\" \"os/exec\" \"syscall\" \"io/ioutil\" \"strconv\" \"path/filepath\" ) func main () { switch os . Args [ 1 ] { case \"run\" : run () case \"child\" : child () default : panic ( \"\u00bfArgumento Invalido?\" ) } } func run () { fmt . Printf ( \"Corriendo '%v' con User ID %d en PID %d \\n\" , os . Args [ 2 :], os . Getuid (), os . Getpid ()) cmd := exec . Command ( \"/proc/self/exe\" , append ([] string { \"child\" }, os . Args [ 2 :] ... ) ... ) cmd . Stdin = os . Stdin cmd . Stdout = os . Stdout cmd . Stderr = os . Stderr cmd . SysProcAttr = & syscall . SysProcAttr { Cloneflags : syscall . CLONE_NEWUTS | syscall . CLONE_NEWUSER | syscall . CLONE_NEWNS | syscall . CLONE_NEWPID , UidMappings : [] syscall . SysProcIDMap { { ContainerID : 0 , HostID : os . Getuid (), Size : 1 , }, }, GidMappings : [] syscall . SysProcIDMap { { ContainerID : 0 , HostID : os . Getgid (), Size : 1 , }, }, } must ( cmd . Run ()) } func child () { fmt . Printf ( \"Corriendo '%v' con User ID %d en PID %d \\n\" , os . Args [ 2 :], os . Getuid (), os . Getpid ()) cg () must ( syscall . Sethostname ([] byte ( \"container\" ))) pivot () must ( syscall . Mount ( \"proc\" , \"proc\" , \"proc\" , 0 , \"\" )) cmd := exec . Command ( os . Args [ 2 ], os . Args [ 3 :] ... ) cmd . Stdin = os . Stdin cmd . Stdout = os . Stdout cmd . Stderr = os . Stderr must ( syscall . Unmount ( \".old_root\" , syscall . MNT_DETACH )) must ( os . Remove ( \".old_root\" )) defer func () { must ( syscall . Unmount ( \"proc\" , 0 )) }() must ( cmd . Run ()) } func cg () { cgroups := \"/sys/fs/cgroup\" pids := filepath . Join ( cgroups , \"pids/demo\" ) if _ , err := os . Stat ( pids ); os . IsNotExist ( err ) { must ( os . Mkdir ( pids , 0755 )) } memory := filepath . Join ( cgroups , \"memory/demo\" ) if _ , err := os . Stat ( memory ); os . IsNotExist ( err ) { must ( os . Mkdir ( memory , 0755 )) } must ( ioutil . WriteFile ( filepath . Join ( pids , \"pids.max\" ), [] byte ( \"22\" ), 0700 )) must ( ioutil . WriteFile ( filepath . Join ( pids , \"cgroup.procs\" ), [] byte ( strconv . Itoa ( os . Getpid ())), 0700 )) must ( ioutil . WriteFile ( filepath . Join ( memory , \"memory.limit_in_bytes\" ), [] byte ( \"2M\" ), 0700 )) must ( ioutil . WriteFile ( filepath . Join ( memory , \"cgroup.procs\" ), [] byte ( strconv . Itoa ( os . Getpid ())), 0700 )) } func pivot () { must ( syscall . Mount ( \"alpinefs\" , \"alpinefs\" , \"\" , syscall . MS_BIND | syscall . MS_REC , \"\" )) if _ , err := os . Stat ( \"alpinefs/.old_root\" ); os . IsNotExist ( err ) { must ( os . Mkdir ( \"alpinefs/.old_root\" , 0700 )) } must ( syscall . PivotRoot ( \"alpinefs\" , \"alpinefs/.old_root\" )) must ( os . Chdir ( \"/\" )) } func must ( err error ) { if err != nil { panic ( err ) } }","title":"Anexo: mejora con pivot_root"}]}