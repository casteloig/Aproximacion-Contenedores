
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      <link rel="icon" href="assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.2.1, mkdocs-material-7.1.8">
    
    
      
        <title>CONTENEDORES</title>
      
    
    
      <link rel="stylesheet" href="assets/stylesheets/main.ca7ac06f.min.css">
      
        
        <link rel="stylesheet" href="assets/stylesheets/palette.f1a3b89f.min.css">
        
      
    
    
    
      
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback">
        <style>:root{--md-text-font-family:"Roboto";--md-code-font-family:"Roboto Mono"}</style>
      
    
    
    
    
      


    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="" data-md-color-primary="none" data-md-color-accent="none">
  
    
    <script>function __prefix(e){return new URL(".",location).pathname+"."+e}function __get(e,t=localStorage){return JSON.parse(t.getItem(__prefix(e)))}</script>
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#una-aproximacion-a-los-contenedores" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="index.html" title="CONTENEDORES" class="md-header__button md-logo" aria-label="CONTENEDORES" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            CONTENEDORES
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Aproximación a los contenedores
            
          </span>
        </div>
      </div>
    </div>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
      </label>
      
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" data-md-state="active" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
      </label>
      <button type="reset" class="md-search__icon md-icon" aria-label="Clear" tabindex="-1">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="index.html" title="CONTENEDORES" class="md-nav__button md-logo" aria-label="CONTENEDORES" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    CONTENEDORES
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" data-md-toggle="toc" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          Aproximación a los contenedores
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="index.html" class="md-nav__link md-nav__link--active">
        Aproximación a los contenedores
      </a>
      
        
<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#que-es-un-contenedor" class="md-nav__link">
    ¿Qué es un contenedor?
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#diferencia-entre-mv-y-contenedores" class="md-nav__link">
    Diferencia entre MV y contenedores
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#historia-de-contenedores" class="md-nav__link">
    Historia de contenedores
  </a>
  
    <nav class="md-nav" aria-label="Historia de contenedores">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#chroot-1979" class="md-nav__link">
    Chroot (1979)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#freebsd-jails-2000" class="md-nav__link">
    FreeBSD Jails (2000)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#solaris-zones-2004" class="md-nav__link">
    Solaris Zones (2004)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cgroups-y-namespaces-2006-2007" class="md-nav__link">
    Cgroups y Namespaces (2006-2007)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lxc-2008" class="md-nav__link">
    LXC (2008)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lmctfy-y-docker-2013" class="md-nav__link">
    LMCTFY y Docker (2013)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oci-2015" class="md-nav__link">
    OCI (2015)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#otras-tecnologias" class="md-nav__link">
    Otras tecnologías
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#arquitectura-de-los-contenedores" class="md-nav__link">
    Arquitectura de los contenedores
  </a>
  
    <nav class="md-nav" aria-label="Arquitectura de los contenedores">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1o-componentes-del-linux-kernel" class="md-nav__link">
    1º Componentes del Linux Kernel
  </a>
  
    <nav class="md-nav" aria-label="1º Componentes del Linux Kernel">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#namespaces" class="md-nav__link">
    Namespaces
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#control-groups" class="md-nav__link">
    Control Groups
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#union-filesystem" class="md-nav__link">
    Union Filesystem
  </a>
  
    <nav class="md-nav" aria-label="Union Filesystem">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#overlayfs" class="md-nav__link">
    OverlayFS
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#capabilities" class="md-nav__link">
    Capabilities
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pivot_root" class="md-nav__link">
    Pivot_root
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2o-container-runtimes" class="md-nav__link">
    2º Container Runtimes
  </a>
  
    <nav class="md-nav" aria-label="2º Container Runtimes">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#low-level-container-runtimes" class="md-nav__link">
    Low-level container runtimes
  </a>
  
    <nav class="md-nav" aria-label="Low-level container runtimes">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#runc-parte-del-stack-de-docker" class="md-nav__link">
    runc (parte del stack de Docker)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#crun" class="md-nav__link">
    crun
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#otros-sandboxed-runtimes" class="md-nav__link">
    Otros Sandboxed Runtimes
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#high-level-container-runtime" class="md-nav__link">
    High-level container runtime
  </a>
  
    <nav class="md-nav" aria-label="High-level container runtime">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#containerd-parte-del-stack-de-docker" class="md-nav__link">
    Containerd (parte del stack de Docker)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cri-o" class="md-nav__link">
    CRI-O
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#3o-container-engines" class="md-nav__link">
    3º Container engines
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#4o-otros-componentes" class="md-nav__link">
    4º Otros componentes
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#4o-orquestadores" class="md-nav__link">
    4º Orquestadores
  </a>
  
    <nav class="md-nav" aria-label="4º Orquestadores">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#kubernetes" class="md-nav__link">
    Kubernetes
  </a>
  
    <nav class="md-nav" aria-label="Kubernetes">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#kubernetes-y-sus-container-runtimes" class="md-nav__link">
    Kubernetes y sus Container runtimes
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="tutoriales/contenedorgo.html" class="md-nav__link">
        Tutorial Go
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="tutoriales/contenedorbash.html" class="md-nav__link">
        Tutorial Bash
      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#que-es-un-contenedor" class="md-nav__link">
    ¿Qué es un contenedor?
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#diferencia-entre-mv-y-contenedores" class="md-nav__link">
    Diferencia entre MV y contenedores
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#historia-de-contenedores" class="md-nav__link">
    Historia de contenedores
  </a>
  
    <nav class="md-nav" aria-label="Historia de contenedores">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#chroot-1979" class="md-nav__link">
    Chroot (1979)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#freebsd-jails-2000" class="md-nav__link">
    FreeBSD Jails (2000)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#solaris-zones-2004" class="md-nav__link">
    Solaris Zones (2004)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cgroups-y-namespaces-2006-2007" class="md-nav__link">
    Cgroups y Namespaces (2006-2007)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lxc-2008" class="md-nav__link">
    LXC (2008)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lmctfy-y-docker-2013" class="md-nav__link">
    LMCTFY y Docker (2013)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oci-2015" class="md-nav__link">
    OCI (2015)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#otras-tecnologias" class="md-nav__link">
    Otras tecnologías
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#arquitectura-de-los-contenedores" class="md-nav__link">
    Arquitectura de los contenedores
  </a>
  
    <nav class="md-nav" aria-label="Arquitectura de los contenedores">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1o-componentes-del-linux-kernel" class="md-nav__link">
    1º Componentes del Linux Kernel
  </a>
  
    <nav class="md-nav" aria-label="1º Componentes del Linux Kernel">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#namespaces" class="md-nav__link">
    Namespaces
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#control-groups" class="md-nav__link">
    Control Groups
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#union-filesystem" class="md-nav__link">
    Union Filesystem
  </a>
  
    <nav class="md-nav" aria-label="Union Filesystem">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#overlayfs" class="md-nav__link">
    OverlayFS
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#capabilities" class="md-nav__link">
    Capabilities
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pivot_root" class="md-nav__link">
    Pivot_root
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2o-container-runtimes" class="md-nav__link">
    2º Container Runtimes
  </a>
  
    <nav class="md-nav" aria-label="2º Container Runtimes">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#low-level-container-runtimes" class="md-nav__link">
    Low-level container runtimes
  </a>
  
    <nav class="md-nav" aria-label="Low-level container runtimes">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#runc-parte-del-stack-de-docker" class="md-nav__link">
    runc (parte del stack de Docker)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#crun" class="md-nav__link">
    crun
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#otros-sandboxed-runtimes" class="md-nav__link">
    Otros Sandboxed Runtimes
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#high-level-container-runtime" class="md-nav__link">
    High-level container runtime
  </a>
  
    <nav class="md-nav" aria-label="High-level container runtime">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#containerd-parte-del-stack-de-docker" class="md-nav__link">
    Containerd (parte del stack de Docker)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cri-o" class="md-nav__link">
    CRI-O
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#3o-container-engines" class="md-nav__link">
    3º Container engines
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#4o-otros-componentes" class="md-nav__link">
    4º Otros componentes
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#4o-orquestadores" class="md-nav__link">
    4º Orquestadores
  </a>
  
    <nav class="md-nav" aria-label="4º Orquestadores">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#kubernetes" class="md-nav__link">
    Kubernetes
  </a>
  
    <nav class="md-nav" aria-label="Kubernetes">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#kubernetes-y-sus-container-runtimes" class="md-nav__link">
    Kubernetes y sus Container runtimes
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content" data-md-component="content">
            <article class="md-content__inner md-typeset">
              
                
                
                <h1 id="una-aproximacion-a-los-contenedores">Una aproximación a los contenedores</h1>
<h2 id="que-es-un-contenedor">¿Qué es un contenedor?</h2>
<p>La <strong>virtualización</strong> es un proceso mediante el cual un software es usado para crear una <strong>abstracción sobre unos recursos</strong>, dando la sensación de que los <strong>elementos hardware se dividen en varias computadores virtuales</strong>.</p>
<p>Existen dos técnicas principales de virtualización:</p>
<ol>
<li><strong>Máquinas virtuales</strong>.</li>
<li><strong>Contenedores</strong> (virtualización ligera).</li>
</ol>
<div class="admonition note">
<p class="admonition-title">Definición</p>
<p>Un <strong>contenedor</strong> es un <strong>límite lógico</strong> que se crea dentro de un sistema operativo proporcionado por el aislamiento de recursos hardware.</p>
<p>La característica principal es que en esta técnica se utilizan herramientas que proporciona el Linux Kernel (como <em>cgroups</em> y <em>namespaces</em>).</p>
</div>
<h2 id="diferencia-entre-mv-y-contenedores">Diferencia entre MV y contenedores</h2>
<figure>
<img src="./img/vm_vs_cont.png" width="650" />
<figcaption>Diferencia infraestructura: VM y contenedor</figcaption>
</figure>

<ul>
<li>Un contenedor es una forma de <strong>virtualización ligera</strong>. </li>
<li>Normalmente envuelve a un <strong>pequeño grupo de procesos</strong>.</li>
<li>Los contenedores <strong>comparten el <em>kernel</em></strong> con el host.</li>
<li>Dentro del contendor se encuentra <strong>únicamente el código, librerías y ejecutables estrictamente necesarios</strong>.</li>
</ul>
<div class="admonition info">
<div class="tabbed-set" data-tabs="1:3"><input checked="checked" id="__tabbed_1_1" name="__tabbed_1" type="radio" /><label for="__tabbed_1_1">Usos principales</label><div class="tabbed-content">
<ul>
<li><strong>Microservicios</strong>: los contenedores <strong>son ligeros y envuelven servicios muy pequeños</strong>, lo que los hace muy aptos para su uso en microservicios.</li>
<li><strong>DevOps + CI/CD</strong>: facilita el ciclo "<em>build, test and deploy</em>".</li>
<li><strong>Cloud</strong>: los contenedores pueden funcionar de forma consistente en, prácticamente, <strong>cualquier lugar</strong>.</li>
</ul>
</div>
<input id="__tabbed_1_2" name="__tabbed_1" type="radio" /><label for="__tabbed_1_2">Ventajas principales</label><div class="tabbed-content">
<ul>
<li><strong>Rapidez y ligereza</strong>.</li>
<li><strong>Portabilidad e independencia de plataformas</strong>.</li>
<li><strong>Escalabilidad</strong>.</li>
</ul>
</div>
<input id="__tabbed_1_3" name="__tabbed_1" type="radio" /><label for="__tabbed_1_3">Desventajas principales</label><div class="tabbed-content">
<ul>
<li><strong>Seguridad</strong>: el aislamiento entre contenedores y el host es menor: puede provocar vulnerabilidades.</li>
<li><strong>Monitorización</strong>: existen varias capas que monitorizar aunque sólo se tenga una aplicación en un contenedor.</li>
<li><strong>Complejidad a gran escala</strong>.</li>
</ul>
</div>
</div>
</div>
<h2 id="historia-de-contenedores">Historia de contenedores</h2>
<h3 id="chroot-1979">Chroot (1979)</h3>
<p><code>chroot</code> es una llamada al sistema que permite <strong>cambiar el directorio raiz de un proceso y de sus hijos</strong> a un nuevo lugar dentro del sistema de archivos. Esto hace que un grupo de procesos tengan una <strong>visión limitada del almacenamiento</strong> del sistema.</p>
<p>El principal <strong>problema</strong> de <code>chroot</code> es que los procesos con permisos de root se pueden <strong>saltar el aislamiento</strong> con facilidad.</p>
<h3 id="freebsd-jails-2000">FreeBSD Jails (2000)</h3>
<p>Fue el <strong>primer "pseudo-contenedor"</strong> y el impulsor de las tecnologías de contenedores que existen hoy en día.</p>
<p>Su objetivo era <strong>"confinar el root omnipotente"</strong>, que da nombre al <a href="http://www.sane.nl/events/sane2000/papers/kamp.pdf">documento</a> donde se presenta la herramienta.</p>
<p>Las Jails dan uso a <code>chroot</code> añadiendo nuevos mecanismos existentes en el sistema operativo. En cada <em>jail</em> los procesos pueden <strong>manipular únicamente los servicios y archivos a los que se le da acceso</strong> (por ello se le dio el nombre de <em>jail</em>: cárcel en inglés, como si los procesos estuvieran en prisión). El administrador del sistema puede separar el sistema en varias celdas asignando un superusuario a cada una <strong>sin perder el control</strong> del sistema completo.</p>
<p>Para <strong>mantener la seguridad</strong> deseada se <strong>desactivaron ciertas llamadas al sistema</strong> (para evitar, por ejemplo, el <em>spoofing</em>), aunque esto impida utilizar ciertas instrucciones comunes como el comando <code>ping</code>.</p>
<p>Por último, <strong>cada celda tiene sus propios UID y GID</strong>: un mismo usuario en una celda puede corresponderse con otro usuario en distinta celda.</p>
<h3 id="solaris-zones-2004">Solaris Zones (2004)</h3>
<p>Los creadores de esta tecnología no sólo buscaban <strong>mantener la seguridad</strong>, sino también <strong>mejorar el uso de recursos a gran escala</strong>. De hecho, se pretendía dar soporte a aplicaciones comerciales potencialmente escalables.</p>
<p>El objetivo era lograr que los <strong>administradores</strong> necesitaran pocos minutos para <strong>configurar y lanzar una nueva <em>zone</em></strong>: el sistema se encargaría de crearla automáticamente añadiendo los límites en recursos compartidos que se consumían (inicialmente sólo CPU).</p>
<p>El administrador puede configurar las propiedades de las <em>zones</em> en tiempo real o mediante scripts.</p>
<p>Existen dos tipos de <em>zones</em>:</p>
<ul>
<li><em>Global zone</em>: es la <em>zone</em> por defecto que tiene control sobre todos los procesos. Siempre existe aunque no se haya creado ninguna manualmente.</li>
<li><em>Non-global zone</em>: son las <em>zones</em> configuradas desde la global.</li>
</ul>
<p>Algo a tener en cuenta es que las Zones se preocupan por <strong>mantener ciertas utilidades</strong> sin dejar a un lado la seguridad (por ejemplo, permite utilizar el comando <code>ping</code>, a diferencia de las <em>jails</em>).</p>
<h3 id="cgroups-y-namespaces-2006-2007">Cgroups y Namespaces (2006-2007)</h3>
<p>En el 2006 se propuso un <em>framework</em> que <strong>agrupa procesos</strong> y aprovecha los mecanismos de control existentes del <em>kernel</em>. El objetivo es que los <strong>usuarios se centren en el controlador de recursos</strong> y se abstraigan de cómo los procesos son gestionados y monitorizados.</p>
<p>Este mecanismo, en un principio, se llamaba <em>process containers</em> pero se cambió el nombre a <strong><em>cgroups</em></strong> para diferenciarlo de los contenedores que conocemos hoy en día, que usan otros mecanismos a parte de los <em>cgroups</em>.</p>
<p>Por otro lado, en el 2002 se creó el primer <strong><em>namespace</em></strong>, el <em>mount namespace</em>. Aunque fue más adelante a partir del año 2007 cuando se comenzó a ver el potencial que podían tener los <em>namespaces</em> junto a otras funcionalidades como los <em>cgroups</em>, así que se empezaron a desarrollar nuevos tipos. En la actualidad existen ocho <em>namespaces</em>.</p>
<h3 id="lxc-2008">LXC (2008)</h3>
<p>Los LXC se podrían considerar los primeros contenedores tal y como conocemos el concepto hoy en día: fue la <strong>primera tecnología en aplicar los dos elementos principales de los contenedores: <em>cgroups</em> y <em>namespaces</em></strong>.</p>
<p>Permite al usuario comunicarse con las facilidades que ofrecen las funcionalidades del <em>kernel</em> mediante una <strong>interfaz en línea de comandos</strong>, sin embargo, no es una herramienta apropiada para realizar tareas de gestión de contenedores en un alto nivel.</p>
<h3 id="lmctfy-y-docker-2013">LMCTFY y Docker (2013)</h3>
<p><strong>LMCTFY</strong> (<em>Let Me Containerize That For You</em>) fue la versión open-source del <strong>stack de Google</strong> a los contenedores de Linux. Su desarrollo <strong>finalizó en 2015</strong> y Google comenzó a transferir parte de la implementación a <em>libcontainer</em>. Ahora mismo es una parte fundamental del stack de Docker y forma parte de OCI.</p>
<p>Por otro lado, <strong>Docker</strong> supuso un despunte en la popularidad de los contenedores en el año de su salida y el crecimiento de ambos conceptos han ido de la mano desde entonces siendo <strong>hoy en día líder en este ámbito</strong>. En sus inicios utilizaba LXC, pero más tarde lo sustituyó por su propia librería <em>libcontainer</em>.</p>
<h3 id="oci-2015">OCI (2015)</h3>
<p><strong>OCI</strong> (<em>Open Container Initiative</em>) es un proyecto de la Linux Foundation cuyo objetivo es <strong>diseñar un estándar abierto para la virtualización basada en contenedores</strong>. Fue establecida en 2015 por Docker y otros líderes de la industria.</p>
<p>Después del lanzamiento de Docker, surgió una comunidad alrededor de los contenedores. Con el paso del tiempo fueron apareciendo nuevas tecnologías y herramientas que satisfacían las neceseidades que iban surgiendo. Este fue el motivo principal por el que surgió este estándar.</p>
<p>Actualmente, OCI define dos especificaciones, aunque <a href="#runc-parte-del-stack-de-docker">hablaremos de ellas más tarde en este documento</a>.</p>
<h3 id="otras-tecnologias">Otras tecnologías</h3>
<p>A lo largo de las dos últimas décadas han ido surgiendo otras tecnologías de virtualización de sistema operativo, pero han sido menos importantes para el ecosistema de los contenedores que las anteriormente mencionadas.</p>
<p>Entre ellas podemos encontrar a <strong>Linux VServer</strong> (2001), <strong>OpenVZ</strong> (2005), <strong>Warden</strong> (2011), <strong>Singularity</strong> (2015) o <strong>Podman</strong> (2018).</p>
<h2 id="arquitectura-de-los-contenedores">Arquitectura de los contenedores</h2>
<p>Dada la ambigüedad con la que muchos profesionales se refieren a cada una de las capas que forman esta arquitectura y, dado que, dependiendo de la tecnología a usar, pueden cambiar ligeramente las funciones que realizan sus componentes, se utilizará como referencia el stack de Docker.</p>
<figure>
<img src="./img/docker_architecture.png" width="600" />
<figcaption>Generalización de la arquitectura de los contenedores a partir de la arquitectura de Docker</figcaption>
</figure>

<p>Comenzaremos el estudio por la parte inferior de la imágen, en los componentes del Linux Kernel, para ir subiendo hasta llegar al <em>Container Engine</em>.</p>
<h3 id="1o-componentes-del-linux-kernel">1º Componentes del Linux Kernel</h3>
<p>Existen numerosos componentes y herramientas del kernel que utilizan los contenedores para aislar los procesos. En concreto aquí estudiaremos cinco de ellos, siendo los más importantes los dos primeros:</p>
<h4 id="namespaces">Namespaces</h4>
<div class="admonition note">
<p class="admonition-title">Definición de namespaces</p>
<p>Proporcionan el <strong>aislamiento entre procesos</strong> mediante la <strong>encapsulación de ciertos recursos</strong> del sistema. De esta forma, hacen creer a los procesos dentro de un contenedor que tienen su propia instancia del recurso, aunque realmente lo están compartiendo.</p>
</div>
<p>Esta herramienta impide que, mediante una vulnerabilidad en un contenedor, unos intrusos puedan acceder a la máquina completa comprometiéndola.</p>
<p>La API del kernel que facilita esta característica tiene tres llamadas principales:</p>
<table>
<thead>
<tr>
<th>Llamada</th>
<th>Descripción</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>clone</code></td>
<td>Crea un proceso hijo ,al igual que <code>fork</code>, pero proporcionando más control sobre qué partes del contexto se comparten.</td>
</tr>
<tr>
<td><code>unshare</code></td>
<td>Crea un nuevo <em>namespace</em> y ejecuta un nuevo proceso dentro de éste.</td>
</tr>
<tr>
<td><code>setns</code></td>
<td>Mueve el hilo actual dentro de un <em>namespace</em> existente</td>
</tr>
<tr>
<td><code>ioctl</code></td>
<td>Ofrece información sobre <em>namespaces</em>  (la información se maneja desde <code>/proc/$PID/ns</code>)</td>
</tr>
</tbody>
</table>
<p>En la actualidad existen 8 <em>namespaces</em> distintos, cada uno de ellos proporciona un <strong>distinto tipo de aislamiento</strong>:</p>
<details class="summary"><summary>Tipos de namespaces</summary><div class="tabbed-set" data-tabs="2:8"><input checked="checked" id="__tabbed_2_1" name="__tabbed_2" type="radio" /><label for="__tabbed_2_1">MNT NS</label><div class="tabbed-content">
<p><strong>Mount Namespace</strong></p>
<p>Fue el primer <em>namespace</em> implementado. En aquel momento no se sabía que iban a crearse más tipos de <em>namespaces</em> así que su <em>flag</em> correspondiente en los comandos de <code>clone</code> y <code>unshare</code> es <code>CLONE_NEWNS</code>.</p>
<div class="admonition note">
<p class="admonition-title">Función</p>
<p>Proporciona <strong>aislamiento</strong> a las estructuras de datos que utiliza el sistema para gestionar los <strong>puntos de montaje</strong>. De esta forma, los procesos en distinto <em>mount namespace</em> tienen una visión distinta de la jerarquía de los sistemas de archivos.</p>
</div>
<p>Algunos usos que ofrece son:</p>
<ul>
<li>Cada usuario puede tener su propio <code>/tmp</code> para aumentar la seguridad frente a un usuario malicioso.</li>
<li>Distintos procesos pueden tener un sistema de archivos raíz (es un concepto parecido a <code>chroot</code>).</li>
<li>Los puntos de montaje pueden ser privados o compartidos.</li>
</ul>
</div>
<input id="__tabbed_2_2" name="__tabbed_2" type="radio" /><label for="__tabbed_2_2">UTS NS</label><div class="tabbed-content">
<p><strong>UNIX Time-Sharing</strong></p>
<p>Desde la implementación del anterior <em>namespace</em> hasta éste pasaron 4 años. Es el más sencillo de entender.</p>
<div class="admonition note">
<p class="admonition-title">Función</p>
<p><strong>Aísla el <em>hostname</em> y el <em>domain-name</em></strong> del contenedor.</p>
</div>
<p>La <em>flag</em> correspondiente es <code>CLONE_NEWUTS</code>.</p>
</div>
<input id="__tabbed_2_3" name="__tabbed_2" type="radio" /><label for="__tabbed_2_3">IPC NS</label><div class="tabbed-content">
<p><strong>Inter Process Communication</strong></p>
<div class="admonition note">
<p class="admonition-title">Función</p>
<p><strong>Aísla la compartición de ciertos recursos que facilitan la comunicación</strong> como la memoria, objetos System V IPC y colas de mensajes POSIX.</p>
</div>
<p>Sin embargo, después de un <code>clone</code> se siguen compartiendo señales, sockets, descriptores de archivos o sondeos de memoria (habría que aislarlos con otras técnicas).</p>
<p>Su flag correspondiente es <code>CLONE_NETIPC</code>.</p>
</div>
<input id="__tabbed_2_4" name="__tabbed_2" type="radio" /><label for="__tabbed_2_4">PID NS</label><div class="tabbed-content">
<p><strong>Process ID</strong></p>
<p>Los procesos de un sistema pertenecen a un árbol de procesos global visible únicamente por el <em>host</em>.</p>
<div class="admonition note">
<p class="admonition-title">Función</p>
<p>Este <em>namespace</em> crea un nuevo <strong>árbol de procesos</strong> propio de cada contenedor.</p>
</div>
<p>Los <strong>procesos</strong> que estén dentro de este <em>namespace</em> <strong>pertenecen</strong>, por tanto, <strong>a dos árboles</strong>, el global y el propio del <em>namespace</em>. De esta forma, un mismo proceso puede tener varios PIDs dependiendo de en qué árbol se consulte.</p>
<p><figure>
    <img src="./img/pid_ns.png" width="500" />
    <figcaption>Distintos árboles para distintos <em>namespaces</em>.</figcaption>
</figure></p>
<p>El primer PID dentro del nuevo <em>namespace</em> siempre es el 1. Este proceso debería tener unas características únicas para poder funcionar como <em>init</em> y así poder tener más de un proceso en un contenedor.</p>
<p>Uno de los principales beneficios que presenta es que los contenedores se pueden migrar de una máquina a otra manteniendo el árbol de procesos.</p>
<p>Su <em>flag</em> es <code>CLONE_NEWPID</code>.</p>
</div>
<input id="__tabbed_2_5" name="__tabbed_2" type="radio" /><label for="__tabbed_2_5">NET NS</label><div class="tabbed-content">
<p><strong>Network</strong></p>
<div class="admonition note">
<p class="admonition-title">Función</p>
<p>Proporciona <strong>aislamiento de los recursos de red</strong>, donde cada contenedor puede tener su propio stack de recursos: tablas de enrutado, reglas de <em>iptables</em>, <em>sockets</em>, etc.</p>
</div>
<p>La <em>flag</em> correspondiente es <code>CLONE_NEWNET</code>.</p>
</div>
<input id="__tabbed_2_6" name="__tabbed_2" type="radio" /><label for="__tabbed_2_6">User NS</label><div class="tabbed-content">
<div class="admonition note">
<p class="admonition-title">Función</p>
<p>Permite que <strong>los procesos puedan creer que están operando como root</strong> dentro de un contenedor, pero fuera del contenedor tienen realmente los privilegios de un usuario común.</p>
</div>
<p>Antes de que existiera este <em>namespace</em>, si un proceso tenía permisos de root en cualquier entorno de aislamiento, también lo tenía en el sistema global, lo que era un problema en lo que a la seguridad se refiere.</p>
<p>En este <em>namespace</em>, el UID dentro del <em>namespace</em> siempre se corresponderá con otro fuera de él en el host. Este mapeo se puede hacer manualmente y elegir qué UID se selecciona dentro del contenedor para un usuario global.</p>
<p>Un ejemplo de mapeo entre las dos tablas de usuarios se puede observar en la siguiente imagen.</p>
<p><figure>
    <img src="./img/user_ns.png" width="500" />
    <figcaption>Ejemplo de mapeo entre un UID del host con un UID dentro del contenedor</figcaption>
</figure></p>
<p>La <em>flag</em> correspondiente es <code>CLONE_NETUSER</code>.</p>
</div>
<input id="__tabbed_2_7" name="__tabbed_2" type="radio" /><label for="__tabbed_2_7">Cgroup NS</label><div class="tabbed-content">
<p>Los <em>cgroups</em> (grupos de control en español) son una funcionalidad del kernel de Linux que trataremos en la <a href="#control-groups">sección</a> que, básicamente, implementan monitorización y limitación de los recursos que consume un grupo de procesos.</p>
<div class="admonition note">
<p class="admonition-title">Función</p>
<p><strong>Virtualiza la vista de los grupos de control</strong> que ven los procesos. Sin esta restricción, un proceso podría observar los grupos de control globales y acceder a la información sobre la limitación de recursos de otros procesos.</p>
</div>
<p>Tiene dos funciones principales:</p>
<ol>
<li>Evita que un grupo de control acceda a los límites de otro superior a él.</li>
<li>Facilita la migración de contenedores al aislar unos grupos de otros. De esta forma podemos ahorrar la necesidad de replicar los límites según se van trasladando los contenedores.</li>
</ol>
<p>La <em>flag</em> correspondiente es <code>CLONE_NEWCGROUP</code>.</p>
</div>
<input id="__tabbed_2_8" name="__tabbed_2" type="radio" /><label for="__tabbed_2_8">Time NS</label><div class="tabbed-content">
<div class="admonition note">
<p class="admonition-title">Función</p>
<p><strong>Virtualiza dos relojes del sistema</strong> permitiendo que, cuando un contenedor se migra de un nodo a otro, estos <strong>relojes son restaurados de forma consistente</strong> partiendo siempre del tiempo que tenía el reloj antes de ser migrado.</p>
</div>
<p>Estos dos relojes son el <code>CLOCK_MONOTONIC</code> y <code>CLOCK_BOOTTIME</code>.</p>
<p>La <em>flag</em> correspondiente es <code>CLONE_NEWTIME</code>.</p>
</div>
</div>
</details>
<h4 id="control-groups">Control Groups</h4>
<p>Antes de que se crearan los grupos de control existían formas para <strong>monitorizar y controlar procesos individuales</strong>, pero <strong>no había soporte</strong> para aplicar esas mismas operaciones <strong>a grupos de procesos</strong>. Por eso se acabaron implementando los <em>Process Containers</em>, que luego se renombraron a <em>cgroups</em>.</p>
<div class="admonition note">
<p class="admonition-title">Definición de Cgroups</p>
<p>Son un <strong><em>framework</em></strong> basado en los mecanismos existentes del kernel para <strong>proporcionar una interfaz y un alcance más global a las operaciones de control y monitorización</strong> de procesos.</p>
<p>Los grupos de control permiten <strong>repartir y asignar recursos entre un grupo de tareas o procesos</strong> del sistema.</p>
</div>
<p>Los grupos de control ofrecen cuatro características principales:</p>
<ol>
<li><strong>Limitación de recursos</strong>, como procesador, memoria, dispositivos E/S, etc.</li>
<li><strong>Priorización</strong>, que es parecida a la anterior característica, pero no limita recursos a procesos sino que le da preferencia en el consumo de recursos a un proceso seleccionado.</li>
<li><strong>Monitorización</strong> de un grupo de procesos para obtener información de qué procesos están consumiendo cuántos recursos.</li>
<li><strong>Freezing de procesos</strong>. Esta es una herramienta que permite paralizar y retomar grupos de procesos. Es muy utilizada en el procesamiento por lotes.</li>
</ol>
<p>Existen dos versiones de <strong>Cgroups</strong>, hoy en día se está intentando hacer la transición en la mayoría de herramientas a la segunda versión. Para comprender esta última versión necesitamos entender tres conceptos:</p>
<ul>
<li><strong>Cgroup</strong>: es un grupo de tareas al que se le asocia uno o más subsistemas.</li>
<li><strong>Subsistema o <em>resource controller</em></strong>: representa un único recurso, como la memoria o el tiempo de CPU.</li>
<li><strong>Jerarquía</strong>: es el conjunto de todos los <em>cgroups</em> en forma de árbol. Cada proceso del sistema está en un <em>cgroup</em> determinado. Cada nodo (o sea, cada <em>cgroup</em>) del árbol tiene asociados uno o más subsistemas. En la versión 2 de los <em>cgroups</em> existe una sóla jerarquía.</li>
</ul>
<p>En la siguiente imagen podemos observar un ejemplo de jerarquía, donde existen cuatro <em>cgroups</em> distintos. Cada uno de ellos tiene asociados varios subsistemas. En el caso del Group_2 los subsistemas asociados son "memoria" y "pids", y sus grupos hijos heredan los mismos subsistemas, pero pueden asociar otros nuevos o disociar los heredados.</p>
<figure>
    <img src="./img/cgroup_jerar.png" width="700" />
    <figcaption>Ejemplo de jerarquía de grupos de control.</figcaption>
</figure>

<p>Cada grupo se añade creando un nuevo directorio dentro de la carpeta raíz <code>/sys/fs/cgroup</code>. En el momento de crear dicha carpeta, el sistema añade los archivos necesarios para gestionar los <em>cgroups</em>.</p>
<details class="note"><summary>¿Cómo añadimos los grupos de control de este ejemplo?</summary><p>Los subsistemas del siguiente ejemplo se añadirían creando en primer lugar cada <em>cgroup</em> y más tarde escribiendo en los subsistemas en los archivos autogenerados:</p>
<div class="highlight"><pre><span></span><code>mkdir /sys/fs/cgroup/Cgroup_1
mkdir /sys/fs/cgroup/Cgroup_2
mkdir /sys/fs/cgroup/Cgroup_2.1
mkdir /sys/fs/cgroup/Cgroup_2.2

<span class="nb">echo</span> <span class="s2">&quot;+memory +io&quot;</span> &gt; /sys/fs/cgroup/Group_1/cgroup.subtree_control
<span class="nb">echo</span> <span class="s2">&quot;+memory +pids&quot;</span> &gt; /sys/fs/cgroup/Group_2/cgroup.subtree_control
<span class="nb">echo</span> <span class="s2">&quot;+io&quot;</span> &gt; /sys/fs/cgroup/Group_2.1/cgroup.subtree_control
<span class="nb">echo</span> <span class="s2">&quot;-pids&quot;</span> &gt; /sys/fs/cgroup/Group_2.2/cgroup.subtree_control
</code></pre></div>
</details>
<h4 id="union-filesystem">Union Filesystem</h4>
<p>Los sistemas de archivos por capas permiten compartir archivos en el disco, lo que supone un ahorro de espacio.</p>
<div class="admonition note">
<p class="admonition-title">Definición</p>
<p>Los <strong>Union Filesystem</strong> son un tipo de sistema de archivos por capas. Permite a los archivos y directorios de sistemas de archivos distintos estar <strong>superpuestos formando un único sistema de archivos</strong>.</p>
</div>
<h5 id="overlayfs">OverlayFS</h5>
<p>Docker, actualmente, utiliza un tipo de Union Filesystem llamado Overlay2. Esta tecnología utiliza tres capas:</p>
<ol>
<li><strong>Base</strong> (sólo lectura): es la capa donde van los archivos base. En terminología de Docker se correspondería con la imagen.</li>
<li><strong>Overlay</strong>: es la capa donde opera el usuario. Ofrece una vista de la capa base y permite operar sobre ella, aunque los cambios no se guardan en esta capa.</li>
<li><strong>Diff</strong>: es la capa donde se guardan los cambios realizados en la capa anterior.</li>
</ol>
<p>Una de las características fundamentales que usan los UnionFS es la <strong>técnica de COW</strong> (<em>Copy On Write</em>) que permite ahorrar el número de copias iguales que se crean al <strong>utilizar siempre una única copia de un archivo</strong> y, en el caso de querer modificarlo, sí que se tendría que crear un nuevo archivo con los cambios guardados.</p>
<figure>
    <img src="./img/overlay.png" width="700" />
    <figcaption>Las tres capas de Overlay2 junto a la técnica COW.</figcaption>
</figure>

<h4 id="capabilities">Capabilities</h4>
<p>El usuario con UID 0 es el root y tiene el control completo del sistema. Esto puede traer problemas recurrentes de seguridad (las Jails ya intentaron confinar el root omnipotente). Por eso, las <em>capabilities</em> proponen una solución.</p>
<div class="admonition note">
<p class="admonition-title">Definición</p>
<p>Las <strong><em>capabilities</em></strong> dividen los permisos que tiene un usuario en varias particiones (cada una de ellas es una <em>capability</em>).</p>
</div>
<p>Un buen ejemplo de su uso podría ser la posibilidad de permitir a un binario poder crear un <em>raw socket</em> como en el caso de la instrucción <code>ping</code> mediante la <em>capability</em> <code>CAP_NET_RAW</code> sin necesidad de asignarle el resto de privilegios que ofrece el usuario root.</p>
<p>Existen dos tipos de <em>capabilities</em>, unas son las asociadas a procesos y otros asociadas a archivos. Las que están asociadas a archivos se unen con las asociadas a procesos cuando un proceso quiere ejecutar un archivo.</p>
<div class="admonition hint">
<p>En la práctica, los contenedores no necesitan todos los privilegios que ofrece el root. Así que, realmente, los usuarios root dentro de los contenedores tienen asignadas algunas <em>capabilities</em> para <strong>ofrecer únicamente ciertos permisos y restringir otros potencialmente inseguros</strong>.</p>
</div>
<h4 id="pivot_root">Pivot_root</h4>
<p>En la sección <a href="#chroot-1979">Historia de los contenedores</a> ya explicamos la importancia que tuvo <code>chroot</code> para aparentar que cambiaba el directorio raíz de un proceso y de sus hijos. El problema que presenta es que no es segura, así que es mejor utilizar la alternativa <em>pivot_root</em>.</p>
<p>La función completa de <strong>pivot_root</strong> es la siguiente:</p>
<div class="highlight"><pre><span></span><code>int pivot_root <span class="o">(</span>const char *new_root, const char *put_old<span class="o">)</span><span class="p">;</span>
</code></pre></div>
<p>Pivot_root <strong>mueve el punto de montaje raíz al directorio put_old</strong> haciéndolo inaccesible para el proceso llamador como para todos sus hijos, mientras que convierte a <strong>new_root en el nuevo punto de montaje raíz</strong>.</p>
<div class="admonition hint">
<p>Esto soluciona las brechas de seguridad de <code>chroot</code> porque se aplica al <em>mount namespace</em>, así que está cambiando únicamente en el <em>namespace</em> del contenedor la posibilidad de acceder a la antigua raíz.</p>
</div>
<h3 id="2o-container-runtimes">2º Container Runtimes</h3>
<div class="admonition note">
<p class="admonition-title">¿Qué es un container runtime?</p>
<p>Un <em>container runtime</em> es la herramienta o capa responsable de que el contenedor se ejecute correctamente (sin incluir los procesos que están dentro del contenedor).</p>
</div>
<p>Este término puede tener diferentes significados dependiendo del proyecto o comunidad donde se consulte, principalmente debido a que el rango de tareas que realiza un <em>runtime</em> no está plenamente definido. En este documento vamos a <strong>separar los <em>container runtimes</em> según las tareas que realicen</strong> en <em>low-level</em> y <em>high-level</em>.</p>
<p>Algunos ejemplos de <strong>low-level</strong> pueden ser <strong>runc, crun, gvisor o kata-runtime</strong>, mientras que entre los ejemplos de <strong>high-level</strong> podemos encontrar a <strong>containerd o CRI-O</strong>.</p>
<details class="info"><summary>¿Y Docker? ¿Dónde lo metemos?</summary><p>En muchas referencias se trata a Docker como un <em>container runtime</em> (refiriéndose a Docker por su significado de <em>daemon</em> más su CLI). Llegados a este punto podemos entender perfectamente que se pueda considerar de esta forma, ya que su función es gestionar los contenedores y las imágenes (definición de <em>high-level container runtime</em>, sin embargo, en este documento se va a colocar en un escalón superior, en los <em>container engines</em>.</p>
<p>Esta decisión se ha tomado en base a dos razones: la primera es que una de las características principales que hacen a esta herramienta más popular que containerd o CRI-O entre los usuarios es su capacidad de facilitar la comunicación con el usuario. La segunda razón es que delega gran parte del trabajo en otro <em>high-level runtime</em>, que por defecto es containerd. Dicho esto, reiteramos que <strong>podría ser perfectamente considerado un <em>container runtime</em></strong>.</p>
<p>De la misma forma, CRI-O o containerd se podrían llegar a considerar <em>container engines</em> si se utilizan a través de plugins CLI que permitan al usuario interactuar debidamente.</p>
<p><strong>En resumen, la forma de referirse a estas tecnologías no es universal y, como hemos dicho, dependiendo de la comunidad y el proyecto, las etiquetas pueden cambiar</strong>.</p>
<p>Una forma de entender gráficamente el porqué de que estos términos sean tan ambiguos se puede observar en la siguiente figura, que muestra de forma muy general y subjetiva el nivel al que operan algunos ejemplos de <em>container runtimes</em>.</p>
<p><figure>
    <img src="./img/runtimes.png" width="700" />
    <figcaption>Nivel al que opera cada container runtime</figcaption>
</figure></p>
</details>
<h4 id="low-level-container-runtimes">Low-level container runtimes</h4>
<p>En esta página nos referiremos por los <strong><em>low-level runtimes</em></strong> a las capas que proporcionan las utilidades básicas como crear <em>namespaces</em> y comenzar el proceso de encapsular una aplicación en un contenedor, es decir, a las herramientas que se <strong>comunican directamente con el kernel</strong>.</p>
<h5 id="runc-parte-del-stack-de-docker">runc (parte del stack de Docker)</h5>
<div class="admonition note">
<p class="admonition-title">Definición</p>
<p>Runc es un CLI que se encarga de crear contenedores y ejecutarlos según la especificación que se le proporcione. Esta especificación sigue el estándar OCI.</p>
</div>
<p>La razón de que sea un <em>low-level container runtime</em> cuando realmente sólo es un CLI es que antiguamente Docker utilizaba como <em>container runtime</em> LXC. Esto cambió más adelante y comenzó a crear junto con Google una librería propia que sustituyera a LXC: <strong><em>libcontainer</em></strong>. Hoy en día, runc utiliza <em>libcontainer</em>, de hecho es su pieza básica y fundamental, por eso se suele considerar que ambos son la misma capa.</p>
<details class="info"><summary>¿Qué estándar OCI?</summary><p>Los estándares OCI se introdujeron en la sección <a href="#OCI-2015">Historia de los contenedores</a>. Consta de dos especificaciones:</p>
<ul>
<li><strong>Imagen</strong>: define el formato del archivo de las imágenes OCI. El objetivo es permitir una serie de herramientas estandarizadas que puedan preparar, construir y transportar una imagen.</li>
<li><strong><em>Runtime</em></strong>: define la configuración, entorno de ejecución y ciclo de vida de un contenedor.</li>
</ul>
<p>Runc sólo implementa la segunda especificación ya que no entiende de imágenes, sino de <em>bundles</em>.</p>
<p>Un <em>bundle</em> es un <strong>conjunto de archivos que contiene todos los datos necesarios</strong> para que un <em>runtime</em> pueda realizar todas las operaciones necesarias para <strong>crear y ejecutar un contenedor</strong>.</p>
</details>
<h5 id="crun">crun</h5>
<p>Se trata de otro <em>low-level container runtime</em> con funciones similares a runc.</p>
<p>La <strong>diferencia principal</strong> radica en que éste está escrito en C, mientras que runc está escrito en Go. Según el creador de crun, Go es un lenguaje multihilo por defecto, lo que no es recomendable para utilizar en un modelo <code>fork/exec</code>.</p>
<p>Además, utiliza los <em>cgroups v2</em>, algo que no todas las herramientas de este ámbito proporcionan.</p>
<h5 id="otros-sandboxed-runtimes">Otros Sandboxed Runtimes</h5>
<p>Las anteriores tecnologías comparten sistema operativo con el host.</p>
<p>Los <strong>Sandboxed runtimes</strong> son otro tipo de herramientas que <strong>aumentan el aislamiento con el host</strong> (aunque disminuyendo la eficiencia), lo que es recomendable en entornos donde varios clientes compartan las mismas máquinas físicas. Esto se logra separando los sistemas operativos del host y de los contenedores.</p>
<p>Algunos ejemplos son <strong>gVisor</strong> (de Google), <strong>Firecracker</strong> (de Amazon) o <strong>Kata</strong> (de OpenStack).</p>
<figure>
    <img src="./img/sandboxed.png" width="740" />
    <figcaption>Comparación genérica de Sandboxed Runtime y runc</figcaption>
</figure>

<h4 id="high-level-container-runtime">High-level container runtime</h4>
<p>En esta página nos referimos por <strong><em>high-level container runtimes</em></strong> a las capas que son responsables de la <strong>gestión y transporte de las imágenes</strong> de los contenedores, así como de <strong>desempaquetarlas y enviarlas</strong> a los <em>low-level container runtimes</em> abstrayéndolos de esas actividades.</p>
<h5 id="containerd-parte-del-stack-de-docker">Containerd (parte del stack de Docker)</h5>
<p>Es un <strong>estándar en la industria dada su portabilidad y facilidad de uso</strong>.</p>
<p>Implementa <strong>ambas especificaciones OCI</strong>:</p>
<ul>
<li><strong>Imagen</strong>: es capaz de <strong>desempaquetar imágenes OCI</strong> y de crear <em>bundles</em> a partir de ellas que el <em>low-level</em> puede entender.</li>
<li><strong>Runtime</strong>: puede comunicarse con un <em>low-level</em> que también implemente el estándar OCI y delegar el trabajo restante en él.</li>
</ul>
<details class="note"><summary>Tareas principales</summary><ol>
<li>Hacer pull y push a las imágenes.</li>
<li>Gestionar el almacenamiento de contenedores.</li>
<li>Gestionar las redes y sus interfaces.</li>
<li>Llamar al <em>low-level container runtime</em> con los parámetros deseados.</li>
</ol>
</details>
<p>Cabe destacar que <strong>containerd</strong> es un <em>daemon</em>, aunque dispone de varios plugins que aumentan sus funcionalidades en gran medida como una interfaz en línea de comandos.</p>
<div class="admonition info">
<p class="admonition-title">Containerd-shim</p>
<p>Si recordamos las capas que forman el stack de Docker, encontramos una pieza llamada <strong>containerd-shim</strong> que no se corresponde con ningún componente generalizado.</p>
<p><figure>
    <img src="./img/containerd-shim.png" width="650" />
    <figcaption>Containerd-shim</figcaption>
</figure></p>
<p><strong>Containerd-shim</strong> es una implementación que <strong>permite separar a los <em>low-level container runtimes</em> de containerd</strong></p>
<p>Cuando containerd quiere crear un contenedor, llama a runc creando una nueva instancia de runc por cada contenedor. Cuando runc termina la tarea de creación se termina a si mismo. A partir de ahora es containerd-shim la pieza que se encarga de tomar las responsabilidades de ser padre del contenedor. </p>
<p><figure>
    <img src="./img/containerd-shim2.png" width="400" />
    <figcaption>Containerd-shim después de que runc acabe su tarea</figcaption>
</figure></p>
</div>
<h5 id="cri-o">CRI-O</h5>
<div class="admonition info">
<p class="admonition-title">CRI (Container Runtime Interface)</p>
<p>CRI (<em>Container Runtime Interface</em>) es la <strong>API que utiliza Kubernetes para hablar con los <em>high-level container runtimes</em></strong>.</p>
<p>El proyecto partió del hecho de que Kubernetes es un orquestrador que delega parte del trabajo en los <em>runtimes</em>. Si se establece una API (un estándar al fin y al cabo) que describa cómo deben interactuar estas tecnologías con Kubernetes se consigue aumentar en gran medida la interoperabilidad.</p>
<p>CRI está basado en <strong>gRPC</strong>, que es un tipo de <em>Remote Procedure Call</em> desarrollado por Google que permite intercomunicación entre varios lenguajes.</p>
</div>
<p>Ahora ya podemos entender mejor qué es CRI-O y por qué se llama así. Su desarrollo lo llevó Red Hat con el objetivo de crear un <em>runtime</em> que soportara de forma nativa la <strong>comunicación mediante CRI, sirviendo de puente entre Kubernetes y un <em>low-level container runtime</em></strong> compatible con OCI.</p>
<details class="note"><summary>Comparación con containerd</summary><p>En primer lugar, cabe destacar que existe un plugin de containerd que permite la comunicación con Kubernetes mediante CRI.</p>
<p>Un <a href="https://www.scitepress.org/Papers/2020/93404/93404.pdf">estudio</a> encabezado por Lennart Espe en el que evalúa el rendimiento de CRI-O y containerd utilizando como <em>low-level</em> tanto a runc como gVisor muestra que, en cuanto a rendimiento general , CRI-O más runc resulta ser la mejor opción.</p>
</details>
<p>Cabe destacar que CRI-O está muy unido a Kubernetes y la gestión de las imágenes es recomendable encomendársela a otro <em>container runtime</em> o <em>container engine</em> como Podman (que es de Red Hat al igual que CRI-O).</p>
<h3 id="3o-container-engines">3º Container engines</h3>
<p>El <em>container engine</em> por excelencia es el propio Docker, formado por Docker <em>daemon</em> más sus APIs y CLI:</p>
<details class="info"><summary>Componentes</summary><div class="tabbed-set" data-tabs="3:3"><input checked="checked" id="__tabbed_3_1" name="__tabbed_3" type="radio" /><label for="__tabbed_3_1"><strong>Docker daemon</strong></label><div class="tabbed-content">
<p>Es el servicio que se ejecuta en la parte del <em>host</em> o servidor y escucha peticiones API. Es la herramienta que comienza la creación del contenedor.</p>
</div>
<input id="__tabbed_3_2" name="__tabbed_3" type="radio" /><label for="__tabbed_3_2"><strong>API REST</strong></label><div class="tabbed-content">
<p>El <em>deamon</em> escucha las peticiones de los clientes a través de esta API.</p>
</div>
<input id="__tabbed_3_3" name="__tabbed_3" type="radio" /><label for="__tabbed_3_3"><strong>CLI</strong></label><div class="tabbed-content">
<p>Es la forma con la que los usuarios, actuando como clientes, se comunican con el <em>daemon</em> a través de la API.</p>
</div>
</div>
</details>
<h3 id="4o-otros-componentes">4º Otros componentes</h3>
<p>Otros componentes que forman el entorno de los contenedores son las <strong>imágenes</strong> y los <strong>registros</strong>.</p>
<div class="admonition note">
<p class="admonition-title">Imágenes</p>
<p>Una imagen es un <strong>archivo binario inmutable</strong> que contiene el código, librerías, dependencias e información que necesita un <em>runtime</em> para crear un contenedor.</p>
</div>
<p>El hecho de que sean archivos inmutables permite que equipos de desarrollo puedan probar software en un <strong>entorno estable y uniforme</strong> ya que <strong>representan un entorno en un momento y condiciones específicas</strong>. EL concepto es parecido a las <em>snapshots</em> en máquinas virtuales.</p>
<div class="admonition hint">
<p>En el caso particular de Docker existe un archivo llamado <code>Dockerfile</code>, que es un fichero de texto que contiene una lista de instrucciones que se van a ejecutar a la hora de crear la imagen, es decir, cuando se ejecute el comando <code>docker build</code>.</p>
<p>El Dockerfile, habitualmente, utiliza como base otra imagen anterior y se le añaden nuevas instrucciones, así, una imagen se crea normalmente mediante el apilamiento de varias imágenes base.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Registros</p>
<p>Un registro es un <strong>sistema o repositorio</strong> que se encarga de <strong>almacenar y distribuir imágenes</strong>.</p>
</div>
<p>Existen dos tipos de repositorios:</p>
<ul>
<li><strong>Públicos</strong>: como Docker Hub. Ideal para equipos pequeños o usuarios que buscan una imagen que cumpla una función específica sin importarles demasiado la privacidad y seguridad.</li>
<li><strong>Privados</strong>: sólo se comparten con los usuarios deseados, normalmente, un equipo de trabajo.</li>
</ul>
<p>En la siguiente imagen podemos ver todos los componentes explicados interactuar entre sí.</p>
<figure>
    <img src="./img/docker_interactua.png" width="770" />
    <figcaption>Todos los componentes explicados de Docker interactuando entre sí.</figcaption>
</figure>

<h3 id="4o-orquestadores">4º Orquestadores</h3>
<p>Administrar un gran número de contenedores es una tarea muy complicada, por eso surgieron ciertas tecnologías que permiten <strong>automatizar el proceso de crear, desplegar y escalar contenedores</strong>. Estas tecnologías son los orquestadores.</p>
<p>Su principal <strong>objetivo</strong> es facilitar la gestión de contenedores localizados en muchos hosts. Esto, además, facilita a los equipos de DevOps integrar sus flujos CI/CD.</p>
<details class="note"><summary>Tareas de los orquestadores</summary><ul>
<li>Configurar y programar contenedores.</li>
<li>Proporcionar el aprovisionamiento y despliegue adecuados de los contenedores.</li>
<li>Asegurar la disponibilidad de los servicios.</li>
<li>Escalar los contenedores.</li>
<li>Controlar los recursos compartidos.</li>
<li>Balancear la carga y el tráfico.</li>
<li>Monitorizar la salud de los contenedores.</li>
<li>Proporcionar seguridad en las interacciones entre los contenedores.</li>
</ul>
</details>
<h4 id="kubernetes">Kubernetes</h4>
<p>Kubernetes es el estándar de facto en la actualidad en cuando a lo que orquestadores se refiere. Es una herramienta <strong>portable</strong> y de <strong>código libre</strong> desarrollado originalmente por Google.</p>
<p>Sus tres principios son <mark>seguridad, facilidad de uso y extensibilidad</mark>.</p>
<p>Cuando se despliega una instancia de Kubernetes se está creando realmente un <em>cluster</em>. Este <em>cluster</em> tiene dos elementos fundamentales: <strong>control plane</strong> y <strong>compute machines</strong> o <strong>nodos</strong>:</p>
<details class="note"><summary>Componentes de un cluster de Kubernetes</summary><div class="tabbed-set" data-tabs="4:2"><input checked="checked" id="__tabbed_4_1" name="__tabbed_4" type="radio" /><label for="__tabbed_4_1">Control Plane</label><div class="tabbed-content">
<ul>
<li><strong>API Server</strong>: maneja las peticiones internas y externas. El CLI <code>kubelet</code> que se suele usar se conecta a este componente.</li>
<li><strong>Scheduler</strong>: controla la salud de los <em>pods</em> y puede añadir o quitar alguno.</li>
<li><strong>Controller Manager</strong>: controla que el <em>cluster</em> funciona correctamente (realmente está formado por varios controladores, cada uno con una función específica).</li>
<li><strong>etcd</strong>: es una base de datos clave-valor distribuida. Permite almacenar la configuración y el estado de los <em>clusters</em>.</li>
</ul>
</div>
<input id="__tabbed_4_2" name="__tabbed_4" type="radio" /><label for="__tabbed_4_2">Nodos</label><div class="tabbed-content">
<ul>
<li><strong>Pods</strong>: representa una instancia de una aplicación, se corresponde con un contenedor o varios altamente acoplados.</li>
<li><strong>Container runtime/engine</strong>: se pueden utilizar varios como containerd, CRI-O o Docker.</li>
<li><strong>Kubelet</strong>: es la aplicación que controla a los contenedores de un mismo <em>pod</em>.</li>
<li><strong>Proxy</strong>: facilita los servicios de red.</li>
</ul>
</div>
</div>
</details>
<details class="info"><summary>Docker-shim</summary><p>Habíamos dicho que Kubernetes utiliza un CRI para comunicarse con los <em>container engines</em> y <em>container runtimes</em>. Como Docker no implementa CRI, la comunidad de Kubernetes creó una herramienta que permite comunicarse con Docker a través de CRI.</p>
<p>Sin embargo, en el año 2020 la comunidad de Kubernetes anunció que no va a seguir manteniendo este plugin, así que el uso de Kubernetes con Docker tiene un futuro incierto.</p>
<p><figure>
    <img src="./img/docker-shim.png" width="770" />
    <figcaption>Docker-shim haciendo de puente entre Kubernetes y Docker.</figcaption>
</figure></p>
</details>
<h5 id="kubernetes-y-sus-container-runtimes">Kubernetes y sus Container runtimes</h5>
<p>Como hemos visto hasta ahora existen <strong>muchas opciones</strong> a la hora de elegir <strong>container runtime</strong> para Kubernetes. Cada opción tiene sus pros y sus contras en la práctica, sin embargo, si analizamos las capas que estaríamos añadiendo en cada opción hay ciertas diferencias que merece la pena destacar.</p>
<figure>
    <img src="./img/k8s_runtimes.png" width="800" />
    <figcaption>Todos los componentes explicados de Docker interactuando entre sí.</figcaption>
</figure>

<p>Como se puede comprobar en la última imagen, dependiendo de la opción que escojamos, vamos a encontrarnos más componentes o menos en el stack. Esto no quiere decir que los stacks con menos saltos sean más eficientes: cada alternativa tiene sus pros y sus contras que habría que estudiar con mayor detenimiento.</p>
<h1 id="ampliacion-de-contenidos">AMPLIACIÓN DE CONTENIDOS</h1>
<p>Los contenidos explicados en esta pagina han sido obtenidos íntegramente de la memoria del TFG "Una aproximación "down-top" a los contenedores" por Ignacio Castelo González en la Universidad de Santiago de Composetela.</p>
                
              
              
                


              
            </article>
          </div>
        </div>
        
      </main>
      
        
<footer class="md-footer">
  
    <nav class="md-footer__inner md-grid" aria-label="Footer">
      
      
        
        <a href="tutoriales/contenedorgo.html" class="md-footer__link md-footer__link--next" aria-label="Next: Tutorial Go" rel="next">
          <div class="md-footer__title">
            <div class="md-ellipsis">
              <span class="md-footer__direction">
                Next
              </span>
              Tutorial Go
            </div>
          </div>
          <div class="md-footer__button md-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4z"/></svg>
          </div>
        </a>
      
    </nav>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        Made with
        <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
          Material for MkDocs
        </a>
        
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    <script id="__config" type="application/json">{"base": ".", "features": [], "translations": {"clipboard.copy": "Copy to clipboard", "clipboard.copied": "Copied to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.placeholder": "Search", "search.result.placeholder": "Type to start searching", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.term.missing": "Missing", "select.version.title": "Select version"}, "search": "assets/javascripts/workers/search.b0710199.min.js", "version": null}</script>
    
    
      <script src="assets/javascripts/bundle.76f349be.min.js"></script>
      
    
  </body>
</html>